{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useMemo, useCallback } from 'react';\nimport { v4 as uuidv4 } from 'uuid';\nimport { format, startOfMonth, endOfMonth, eachDayOfInterval, isAfter, isBefore, isSameDay, isWeekend, getDate } from 'date-fns';\nimport { useAuth } from '../context/AuthContext';\nconst ENTRIES_STORAGE_KEY = 'personal-budget-tracker-entries';\nconst RECURRING_PAYMENTS_STORAGE_KEY = 'personal-budget-tracker-recurring-payments';\n\n// Helper function to safely handle date serialization\nconst dateReviver = (key, value) => {\n  if (key === 'date' || key === 'startDate' || key === 'endDate') {\n    return new Date(value);\n  }\n  return value;\n};\nexport const useFinancialData = (currentDate = new Date()) => {\n  _s();\n  const {\n    currentUser\n  } = useAuth();\n  const [entries, setEntries] = useState([]);\n  const [recurringPayments, setRecurringPayments] = useState([]);\n\n  // Get storage key for the current user\n  const getStorageKey = useCallback(key => {\n    return currentUser ? `${key}-${currentUser.id}` : key;\n  }, [currentUser]);\n\n  // Load entries from localStorage\n  useEffect(() => {\n    const savedEntries = localStorage.getItem(getStorageKey(ENTRIES_STORAGE_KEY));\n    if (savedEntries) {\n      const parsedEntries = JSON.parse(savedEntries, dateReviver);\n      setEntries(parsedEntries.map(entry => ({\n        ...entry,\n        date: new Date(entry.date)\n      })));\n    }\n  }, [getStorageKey]);\n\n  // Save entries to localStorage\n  useEffect(() => {\n    if (entries.length > 0) {\n      localStorage.setItem(getStorageKey(ENTRIES_STORAGE_KEY), JSON.stringify(entries));\n    }\n  }, [entries, getStorageKey]);\n\n  // Load recurring payments from localStorage\n  useEffect(() => {\n    const savedRecurringPayments = localStorage.getItem(getStorageKey(RECURRING_PAYMENTS_STORAGE_KEY));\n    if (savedRecurringPayments) {\n      const parsedPayments = JSON.parse(savedRecurringPayments, dateReviver);\n      setRecurringPayments(parsedPayments.map(payment => ({\n        ...payment,\n        startDate: new Date(payment.startDate),\n        endDate: payment.endDate ? new Date(payment.endDate) : undefined,\n        validFrom: new Date(payment.validFrom),\n        validUntil: payment.validUntil ? new Date(payment.validUntil) : undefined\n      })));\n    }\n  }, [getStorageKey]);\n\n  // Save recurring payments to localStorage\n  useEffect(() => {\n    if (recurringPayments.length > 0) {\n      localStorage.setItem(getStorageKey(RECURRING_PAYMENTS_STORAGE_KEY), JSON.stringify(recurringPayments));\n    }\n  }, [recurringPayments, getStorageKey]);\n\n  // Process recurring payments and generate entries\n  useEffect(() => {\n    const processRecurringPayments = () => {\n      // Current actual date (today)\n      const today = new Date();\n      today.setHours(0, 0, 0, 0);\n\n      // Selected month in the UI (might be different from current month)\n      const selectedMonthStart = startOfMonth(currentDate);\n      const selectedMonthEnd = endOfMonth(currentDate);\n\n      // Consider a period of up to 30 days in the past from today (for historical data)\n      const pastProcessingDate = new Date(today);\n      pastProcessingDate.setDate(pastProcessingDate.getDate() - 30);\n\n      // The start of processing should be the earlier of:\n      // 1. 30 days before today (for recent past entries)\n      // 2. The start of the selected month (for viewing past/future months)\n      const startDate = new Date(Math.min(pastProcessingDate.getTime(), selectedMonthStart.getTime()));\n\n      // The end of processing should be the later of:\n      // 1. The end of the current actual month (for immediate visibility)\n      // 2. The end of the selected month (for viewing past/future months)\n      const endDate = new Date(Math.max(endOfMonth(today).getTime(), selectedMonthEnd.getTime()));\n\n      // Prepare new entries generated from recurring payments\n      const newEntries = [];\n\n      // Loop through all recurring payments\n      recurringPayments.forEach(payment => {\n        if (!payment.isActive) return;\n\n        // Check if the payment is valid during any part of our processing window\n        const paymentEndDate = payment.validUntil || new Date(9999, 11, 31); // If no end date, use far future\n\n        // If the payment's validity period doesn't overlap with our processing period, skip it\n        if (isAfter(payment.validFrom, endDate) || isBefore(paymentEndDate, startDate)) {\n          return;\n        }\n\n        // Get dates to process based on schedule type\n        let datesToProcess = [];\n\n        // Define start date for processing (max of payment's start date or our processing window start)\n        const processingStart = new Date(Math.max(payment.startDate.getTime(), startDate.getTime()));\n\n        // Define end date for processing (min of payment's end date or processing window end)\n        const processingEnd = payment.endDate && isBefore(payment.endDate, endDate) ? payment.endDate : endDate;\n\n        // Don't process if the processing period is invalid\n        if (isAfter(processingStart, processingEnd)) return;\n\n        // Get candidate dates based on schedule type\n        switch (payment.scheduleType) {\n          case 'specific-date':\n            // For monthly payments on a specific day of month\n            if (payment.frequency === 'monthly' && payment.dayOfMonth) {\n              // Get all days in the processing range\n              const allDays = eachDayOfInterval({\n                start: processingStart,\n                end: processingEnd\n              });\n              // Filter for days that match the day of month\n              datesToProcess = allDays.filter(date => getDate(date) === payment.dayOfMonth);\n            }\n            // For yearly payments on a specific day of a specific month\n            else if (payment.frequency === 'yearly' && payment.dayOfMonth) {\n              // Get all days in the processing range\n              const allDays = eachDayOfInterval({\n                start: processingStart,\n                end: processingEnd\n              });\n              // Filter for days that match both the month and day\n              datesToProcess = allDays.filter(date => getDate(date) === payment.dayOfMonth && date.getMonth() === payment.startDate.getMonth());\n            }\n            break;\n          case 'weekdays-only':\n            // Get all weekdays within the processing window\n            datesToProcess = eachDayOfInterval({\n              start: processingStart,\n              end: processingEnd\n            }).filter(date => !isWeekend(date));\n            break;\n          case 'weekends-only':\n            // Get all weekend days within the processing window\n            datesToProcess = eachDayOfInterval({\n              start: processingStart,\n              end: processingEnd\n            }).filter(date => isWeekend(date));\n            break;\n          case 'custom-range':\n            // Get all dates within the custom range\n            datesToProcess = eachDayOfInterval({\n              start: processingStart,\n              end: processingEnd\n            });\n\n            // Apply frequency filtering\n            switch (payment.frequency) {\n              case 'daily':\n                // All days are included, so no additional filtering\n                break;\n              case 'weekly':\n                // Keep only days whose day of week matches the original start date\n                datesToProcess = datesToProcess.filter(date => date.getDay() === payment.startDate.getDay());\n                break;\n              case 'monthly':\n                // Keep only days whose day of month matches the original start date\n                datesToProcess = datesToProcess.filter(date => getDate(date) === getDate(payment.startDate));\n                break;\n              case 'yearly':\n                // Keep only days whose day and month match the original start date\n                datesToProcess = datesToProcess.filter(date => getDate(date) === getDate(payment.startDate) && date.getMonth() === payment.startDate.getMonth());\n                break;\n            }\n            break;\n        }\n\n        // Create entries for each date to process\n        datesToProcess.forEach(date => {\n          // Check if an entry for this recurring payment already exists on this date\n          const entryExists = entries.some(entry => isSameDay(entry.date, date) && entry.description === `[Recurring] ${payment.description}`);\n          if (!entryExists) {\n            // Create a new entry for this recurring payment\n            newEntries.push({\n              id: uuidv4(),\n              date: new Date(date),\n              amount: payment.amount,\n              description: `[Recurring] ${payment.description}`,\n              type: payment.type\n            });\n          }\n        });\n      });\n\n      // Add new entries if any were generated\n      if (newEntries.length > 0) {\n        setEntries(prevEntries => [...prevEntries, ...newEntries]);\n      }\n    };\n\n    // Process recurring payments\n    if (recurringPayments.length > 0) {\n      processRecurringPayments();\n    }\n  }, [recurringPayments, entries, currentDate]);\n\n  // Calculate month data\n  const monthData = useMemo(() => {\n    const startDate = startOfMonth(currentDate);\n    const endDate = endOfMonth(currentDate);\n    const daysInMonth = eachDayOfInterval({\n      start: startDate,\n      end: endDate\n    });\n    const days = daysInMonth.reduce((acc, day) => {\n      const formattedDate = format(day, 'yyyy-MM-dd');\n      const dayEntries = entries.filter(entry => isSameDay(entry.date, day));\n      const totalIncome = dayEntries.filter(entry => entry.type === 'income').reduce((sum, entry) => sum + entry.amount, 0);\n      const totalExpenses = dayEntries.filter(entry => entry.type === 'expense').reduce((sum, entry) => sum + entry.amount, 0);\n      acc[formattedDate] = {\n        date: day,\n        entries: dayEntries,\n        totalIncome,\n        totalExpenses,\n        dailyBalance: totalIncome - totalExpenses,\n        runningBalance: 0 // Calculated after all days are processed\n      };\n      return acc;\n    }, {});\n\n    // Calculate running balance\n    let runningBalance = 0;\n    for (const day of daysInMonth) {\n      const formattedDate = format(day, 'yyyy-MM-dd');\n      runningBalance += days[formattedDate].dailyBalance;\n      days[formattedDate].runningBalance = runningBalance;\n    }\n\n    // Calculate total income, expenses, and balance for the month\n    const totalIncome = Object.values(days).reduce((sum, day) => sum + day.totalIncome, 0);\n    const totalExpenses = Object.values(days).reduce((sum, day) => sum + day.totalExpenses, 0);\n    return {\n      days,\n      totalIncome,\n      totalExpenses,\n      monthlyBalance: totalIncome - totalExpenses\n    };\n  }, [currentDate, entries]);\n\n  // Calculate year data\n  const yearData = useMemo(() => {\n    const year = currentDate.getFullYear();\n    const months = Array.from({\n      length: 12\n    }, (_, i) => i);\n    const monthSummaries = months.map(month => {\n      const monthEntries = entries.filter(entry => entry.date.getFullYear() === year && entry.date.getMonth() === month);\n      const totalIncome = monthEntries.filter(entry => entry.type === 'income').reduce((sum, entry) => sum + entry.amount, 0);\n      const totalExpenses = monthEntries.filter(entry => entry.type === 'expense').reduce((sum, entry) => sum + entry.amount, 0);\n      return {\n        month,\n        year,\n        totalIncome,\n        totalExpenses,\n        monthlyBalance: totalIncome - totalExpenses\n      };\n    });\n    const totalIncome = monthSummaries.reduce((sum, month) => sum + month.totalIncome, 0);\n    const totalExpenses = monthSummaries.reduce((sum, month) => sum + month.totalExpenses, 0);\n    return {\n      year,\n      months: monthSummaries,\n      totalIncome,\n      totalExpenses,\n      yearlyBalance: totalIncome - totalExpenses\n    };\n  }, [currentDate, entries]);\n\n  // Add a new financial entry\n  const addEntry = entry => {\n    const newEntry = {\n      ...entry,\n      id: uuidv4()\n    };\n    setEntries(prevEntries => [...prevEntries, newEntry]);\n  };\n\n  // Update an existing financial entry\n  const updateEntry = updatedEntry => {\n    setEntries(prevEntries => prevEntries.map(entry => entry.id === updatedEntry.id ? updatedEntry : entry));\n  };\n\n  // Delete a financial entry\n  const deleteEntry = id => {\n    setEntries(prevEntries => prevEntries.filter(entry => entry.id !== id));\n  };\n\n  // Add a new recurring payment\n  const addRecurringPayment = payment => {\n    const newPayment = {\n      ...payment,\n      id: uuidv4()\n    };\n\n    // Immediately process this new payment to create entries\n    const today = new Date();\n    today.setHours(0, 0, 0, 0);\n\n    // Selected month in the UI\n    const selectedMonthStart = startOfMonth(currentDate);\n    const selectedMonthEnd = endOfMonth(currentDate);\n\n    // The end date should be the later of today's month end or the selected month end\n    const endDate = new Date(Math.max(endOfMonth(today).getTime(), selectedMonthEnd.getTime()));\n    let datesToProcess = [];\n    if (newPayment.isActive) {\n      // Get the earlier of the selected month start or today (for processing)\n      const startDate = new Date(Math.min(today.getTime(), selectedMonthStart.getTime()));\n\n      // Check if the payment schedule is valid \n      const processingStart = new Date(Math.max(newPayment.startDate.getTime(), startDate.getTime()));\n      const processingEnd = newPayment.endDate && isBefore(newPayment.endDate, endDate) ? newPayment.endDate : endDate;\n      if (!isAfter(processingStart, processingEnd)) {\n        // Get dates based on schedule type\n        switch (newPayment.scheduleType) {\n          case 'specific-date':\n            if (newPayment.frequency === 'monthly' && newPayment.dayOfMonth) {\n              const allDays = eachDayOfInterval({\n                start: processingStart,\n                end: processingEnd\n              });\n              datesToProcess = allDays.filter(date => getDate(date) === newPayment.dayOfMonth);\n            } else if (newPayment.frequency === 'yearly' && newPayment.dayOfMonth) {\n              const allDays = eachDayOfInterval({\n                start: processingStart,\n                end: processingEnd\n              });\n              datesToProcess = allDays.filter(date => getDate(date) === newPayment.dayOfMonth && date.getMonth() === newPayment.startDate.getMonth());\n            }\n            break;\n          case 'weekdays-only':\n            datesToProcess = eachDayOfInterval({\n              start: processingStart,\n              end: processingEnd\n            }).filter(date => !isWeekend(date));\n            break;\n          case 'weekends-only':\n            datesToProcess = eachDayOfInterval({\n              start: processingStart,\n              end: processingEnd\n            }).filter(date => isWeekend(date));\n            break;\n          case 'custom-range':\n            datesToProcess = eachDayOfInterval({\n              start: processingStart,\n              end: processingEnd\n            });\n            switch (newPayment.frequency) {\n              case 'daily':\n                break;\n              case 'weekly':\n                datesToProcess = datesToProcess.filter(date => date.getDay() === newPayment.startDate.getDay());\n                break;\n              case 'monthly':\n                datesToProcess = datesToProcess.filter(date => getDate(date) === getDate(newPayment.startDate));\n                break;\n              case 'yearly':\n                datesToProcess = datesToProcess.filter(date => getDate(date) === getDate(newPayment.startDate) && date.getMonth() === newPayment.startDate.getMonth());\n                break;\n            }\n            break;\n        }\n\n        // Create entries for dates\n        const newEntries = datesToProcess.map(date => ({\n          id: uuidv4(),\n          date: new Date(date),\n          amount: newPayment.amount,\n          description: `[Recurring] ${newPayment.description}`,\n          type: newPayment.type\n        }));\n        if (newEntries.length > 0) {\n          setEntries(prevEntries => [...prevEntries, ...newEntries]);\n        }\n      }\n    }\n    setRecurringPayments(prevPayments => [...prevPayments, newPayment]);\n  };\n\n  // Update an existing recurring payment\n  const updateRecurringPayment = updatedPayment => {\n    // Get the existing payment to compare descriptions\n    const existingPayment = recurringPayments.find(p => p.id === updatedPayment.id);\n    if (!existingPayment) return;\n\n    // First, remove all existing entries for this recurring payment\n    setEntries(prevEntries => prevEntries.filter(entry => !entry.description.startsWith(`[Recurring] ${existingPayment.description}`)));\n\n    // Update the recurring payment\n    setRecurringPayments(prevPayments => prevPayments.map(payment => payment.id === updatedPayment.id ? updatedPayment : payment));\n\n    // If the payment is active, process it immediately to create new entries\n    if (updatedPayment.isActive) {\n      const today = new Date();\n      today.setHours(0, 0, 0, 0);\n      const selectedMonthStart = startOfMonth(currentDate);\n      const selectedMonthEnd = endOfMonth(currentDate);\n      const endDate = new Date(Math.max(endOfMonth(today).getTime(), selectedMonthEnd.getTime()));\n      let datesToProcess = [];\n      const startDate = new Date(Math.min(today.getTime(), selectedMonthStart.getTime()));\n      const processingStart = new Date(Math.max(updatedPayment.startDate.getTime(), startDate.getTime()));\n      const processingEnd = updatedPayment.endDate && isBefore(updatedPayment.endDate, endDate) ? updatedPayment.endDate : endDate;\n      if (!isAfter(processingStart, processingEnd)) {\n        switch (updatedPayment.scheduleType) {\n          case 'specific-date':\n            if (updatedPayment.frequency === 'monthly' && updatedPayment.dayOfMonth) {\n              const allDays = eachDayOfInterval({\n                start: processingStart,\n                end: processingEnd\n              });\n              datesToProcess = allDays.filter(date => getDate(date) === updatedPayment.dayOfMonth);\n            } else if (updatedPayment.frequency === 'yearly' && updatedPayment.dayOfMonth) {\n              const allDays = eachDayOfInterval({\n                start: processingStart,\n                end: processingEnd\n              });\n              datesToProcess = allDays.filter(date => getDate(date) === updatedPayment.dayOfMonth && date.getMonth() === updatedPayment.startDate.getMonth());\n            }\n            break;\n          case 'weekdays-only':\n            datesToProcess = eachDayOfInterval({\n              start: processingStart,\n              end: processingEnd\n            }).filter(date => !isWeekend(date));\n            break;\n          case 'weekends-only':\n            datesToProcess = eachDayOfInterval({\n              start: processingStart,\n              end: processingEnd\n            }).filter(date => isWeekend(date));\n            break;\n          case 'custom-range':\n            datesToProcess = eachDayOfInterval({\n              start: processingStart,\n              end: processingEnd\n            });\n            switch (updatedPayment.frequency) {\n              case 'daily':\n                break;\n              case 'weekly':\n                datesToProcess = datesToProcess.filter(date => date.getDay() === updatedPayment.startDate.getDay());\n                break;\n              case 'monthly':\n                datesToProcess = datesToProcess.filter(date => getDate(date) === getDate(updatedPayment.startDate));\n                break;\n              case 'yearly':\n                datesToProcess = datesToProcess.filter(date => getDate(date) === getDate(updatedPayment.startDate) && date.getMonth() === updatedPayment.startDate.getMonth());\n                break;\n            }\n            break;\n        }\n\n        // Create new entries for the updated payment\n        const newEntries = datesToProcess.map(date => ({\n          id: uuidv4(),\n          date: new Date(date),\n          amount: updatedPayment.amount,\n          description: `[Recurring] ${updatedPayment.description}`,\n          type: updatedPayment.type\n        }));\n        if (newEntries.length > 0) {\n          setEntries(prevEntries => [...prevEntries, ...newEntries]);\n        }\n      }\n    }\n  };\n\n  // Delete a recurring payment\n  const deleteRecurringPayment = id => {\n    // Get the payment before deleting it\n    const paymentToDelete = recurringPayments.find(payment => payment.id === id);\n    if (paymentToDelete) {\n      // Remove all entries associated with this recurring payment\n      setEntries(prevEntries => prevEntries.filter(entry => !entry.description.startsWith(`[Recurring] ${paymentToDelete.description}`)));\n    }\n\n    // Remove the recurring payment\n    setRecurringPayments(prevPayments => prevPayments.filter(payment => payment.id !== id));\n  };\n  return {\n    entries,\n    addEntry,\n    updateEntry,\n    deleteEntry,\n    recurringPayments,\n    addRecurringPayment,\n    updateRecurringPayment,\n    deleteRecurringPayment,\n    monthData,\n    yearData\n  };\n};\n_s(useFinancialData, \"DMbKBlC/dti7WdW+KomCtlT1MMM=\", false, function () {\n  return [useAuth];\n});","map":{"version":3,"names":["useState","useEffect","useMemo","useCallback","v4","uuidv4","format","startOfMonth","endOfMonth","eachDayOfInterval","isAfter","isBefore","isSameDay","isWeekend","getDate","useAuth","ENTRIES_STORAGE_KEY","RECURRING_PAYMENTS_STORAGE_KEY","dateReviver","key","value","Date","useFinancialData","currentDate","_s","currentUser","entries","setEntries","recurringPayments","setRecurringPayments","getStorageKey","id","savedEntries","localStorage","getItem","parsedEntries","JSON","parse","map","entry","date","length","setItem","stringify","savedRecurringPayments","parsedPayments","payment","startDate","endDate","undefined","validFrom","validUntil","processRecurringPayments","today","setHours","selectedMonthStart","selectedMonthEnd","pastProcessingDate","setDate","Math","min","getTime","max","newEntries","forEach","isActive","paymentEndDate","datesToProcess","processingStart","processingEnd","scheduleType","frequency","dayOfMonth","allDays","start","end","filter","getMonth","getDay","entryExists","some","description","push","amount","type","prevEntries","monthData","daysInMonth","days","reduce","acc","day","formattedDate","dayEntries","totalIncome","sum","totalExpenses","dailyBalance","runningBalance","Object","values","monthlyBalance","yearData","year","getFullYear","months","Array","from","_","i","monthSummaries","month","monthEntries","yearlyBalance","addEntry","newEntry","updateEntry","updatedEntry","deleteEntry","addRecurringPayment","newPayment","prevPayments","updateRecurringPayment","updatedPayment","existingPayment","find","p","startsWith","deleteRecurringPayment","paymentToDelete"],"sources":["C:/Users/Administrator/Downloads/personal-budget-tracker/src/hooks/useFinancialData.ts"],"sourcesContent":["import { useState, useEffect, useMemo, useCallback } from 'react';\nimport { \n  FinancialEntry, \n  RecurringPayment\n} from '../types';\nimport { v4 as uuidv4 } from 'uuid';\nimport { \n  format, \n  startOfMonth, \n  endOfMonth, \n  eachDayOfInterval, \n  isAfter, \n  isBefore, \n  isSameDay, \n  isWeekend,\n  getDate\n} from 'date-fns';\nimport { useAuth } from '../context/AuthContext';\n\nconst ENTRIES_STORAGE_KEY = 'personal-budget-tracker-entries';\nconst RECURRING_PAYMENTS_STORAGE_KEY = 'personal-budget-tracker-recurring-payments';\n\n// Helper function to safely handle date serialization\nconst dateReviver = (key: string, value: any) => {\n  if (key === 'date' || key === 'startDate' || key === 'endDate') {\n    return new Date(value);\n  }\n  return value;\n};\n\nexport const useFinancialData = (currentDate: Date = new Date()) => {\n  const { currentUser } = useAuth();\n  const [entries, setEntries] = useState<FinancialEntry[]>([]);\n  const [recurringPayments, setRecurringPayments] = useState<RecurringPayment[]>([]);\n\n  // Get storage key for the current user\n  const getStorageKey = useCallback((key: string) => {\n    return currentUser \n      ? `${key}-${currentUser.id}`\n      : key;\n  }, [currentUser]);\n\n  // Load entries from localStorage\n  useEffect(() => {\n    const savedEntries = localStorage.getItem(getStorageKey(ENTRIES_STORAGE_KEY));\n    if (savedEntries) {\n      const parsedEntries = JSON.parse(savedEntries, dateReviver);\n      setEntries(parsedEntries.map((entry: any) => ({\n        ...entry,\n        date: new Date(entry.date)\n      })));\n    }\n  }, [getStorageKey]);\n\n  // Save entries to localStorage\n  useEffect(() => {\n    if (entries.length > 0) {\n      localStorage.setItem(getStorageKey(ENTRIES_STORAGE_KEY), JSON.stringify(entries));\n    }\n  }, [entries, getStorageKey]);\n\n  // Load recurring payments from localStorage\n  useEffect(() => {\n    const savedRecurringPayments = localStorage.getItem(getStorageKey(RECURRING_PAYMENTS_STORAGE_KEY));\n    if (savedRecurringPayments) {\n      const parsedPayments = JSON.parse(savedRecurringPayments, dateReviver);\n      setRecurringPayments(parsedPayments.map((payment: any) => ({\n        ...payment,\n        startDate: new Date(payment.startDate),\n        endDate: payment.endDate ? new Date(payment.endDate) : undefined,\n        validFrom: new Date(payment.validFrom),\n        validUntil: payment.validUntil ? new Date(payment.validUntil) : undefined\n      })));\n    }\n  }, [getStorageKey]);\n\n  // Save recurring payments to localStorage\n  useEffect(() => {\n    if (recurringPayments.length > 0) {\n      localStorage.setItem(getStorageKey(RECURRING_PAYMENTS_STORAGE_KEY), JSON.stringify(recurringPayments));\n    }\n  }, [recurringPayments, getStorageKey]);\n\n  // Process recurring payments and generate entries\n  useEffect(() => {\n    const processRecurringPayments = () => {\n      // Current actual date (today)\n      const today = new Date();\n      today.setHours(0, 0, 0, 0);\n      \n      // Selected month in the UI (might be different from current month)\n      const selectedMonthStart = startOfMonth(currentDate);\n      const selectedMonthEnd = endOfMonth(currentDate);\n      \n      // Consider a period of up to 30 days in the past from today (for historical data)\n      const pastProcessingDate = new Date(today);\n      pastProcessingDate.setDate(pastProcessingDate.getDate() - 30);\n      \n      // The start of processing should be the earlier of:\n      // 1. 30 days before today (for recent past entries)\n      // 2. The start of the selected month (for viewing past/future months)\n      const startDate = new Date(Math.min(pastProcessingDate.getTime(), selectedMonthStart.getTime()));\n      \n      // The end of processing should be the later of:\n      // 1. The end of the current actual month (for immediate visibility)\n      // 2. The end of the selected month (for viewing past/future months)\n      const endDate = new Date(\n        Math.max(\n          endOfMonth(today).getTime(),\n          selectedMonthEnd.getTime()\n        )\n      );\n      \n      // Prepare new entries generated from recurring payments\n      const newEntries: FinancialEntry[] = [];\n\n      // Loop through all recurring payments\n      recurringPayments.forEach(payment => {\n        if (!payment.isActive) return;\n\n        // Check if the payment is valid during any part of our processing window\n        const paymentEndDate = payment.validUntil || new Date(9999, 11, 31); // If no end date, use far future\n        \n        // If the payment's validity period doesn't overlap with our processing period, skip it\n        if (isAfter(payment.validFrom, endDate) || isBefore(paymentEndDate, startDate)) {\n          return;\n        }\n\n        // Get dates to process based on schedule type\n        let datesToProcess: Date[] = [];\n        \n        // Define start date for processing (max of payment's start date or our processing window start)\n        const processingStart = new Date(Math.max(payment.startDate.getTime(), startDate.getTime()));\n        \n        // Define end date for processing (min of payment's end date or processing window end)\n        const processingEnd = payment.endDate && isBefore(payment.endDate, endDate) \n          ? payment.endDate \n          : endDate;\n\n        // Don't process if the processing period is invalid\n        if (isAfter(processingStart, processingEnd)) return;\n\n        // Get candidate dates based on schedule type\n        switch (payment.scheduleType) {\n          case 'specific-date':\n            // For monthly payments on a specific day of month\n            if (payment.frequency === 'monthly' && payment.dayOfMonth) {\n              // Get all days in the processing range\n              const allDays = eachDayOfInterval({ start: processingStart, end: processingEnd });\n              // Filter for days that match the day of month\n              datesToProcess = allDays.filter(date => getDate(date) === payment.dayOfMonth);\n            } \n            // For yearly payments on a specific day of a specific month\n            else if (payment.frequency === 'yearly' && payment.dayOfMonth) {\n              // Get all days in the processing range\n              const allDays = eachDayOfInterval({ start: processingStart, end: processingEnd });\n              // Filter for days that match both the month and day\n              datesToProcess = allDays.filter(date => \n                getDate(date) === payment.dayOfMonth &&\n                date.getMonth() === payment.startDate.getMonth()\n              );\n            }\n            break;\n            \n          case 'weekdays-only':\n            // Get all weekdays within the processing window\n            datesToProcess = eachDayOfInterval({ start: processingStart, end: processingEnd })\n              .filter(date => !isWeekend(date));\n            break;\n            \n          case 'weekends-only':\n            // Get all weekend days within the processing window\n            datesToProcess = eachDayOfInterval({ start: processingStart, end: processingEnd })\n              .filter(date => isWeekend(date));\n            break;\n            \n          case 'custom-range':\n            // Get all dates within the custom range\n            datesToProcess = eachDayOfInterval({ start: processingStart, end: processingEnd });\n            \n            // Apply frequency filtering\n            switch (payment.frequency) {\n              case 'daily':\n                // All days are included, so no additional filtering\n                break;\n                \n              case 'weekly':\n                // Keep only days whose day of week matches the original start date\n                datesToProcess = datesToProcess.filter(date => \n                  date.getDay() === payment.startDate.getDay()\n                );\n                break;\n                \n              case 'monthly':\n                // Keep only days whose day of month matches the original start date\n                datesToProcess = datesToProcess.filter(date => \n                  getDate(date) === getDate(payment.startDate)\n                );\n                break;\n                \n              case 'yearly':\n                // Keep only days whose day and month match the original start date\n                datesToProcess = datesToProcess.filter(date => \n                  getDate(date) === getDate(payment.startDate) && \n                  date.getMonth() === payment.startDate.getMonth()\n                );\n                break;\n            }\n            break;\n        }\n\n        // Create entries for each date to process\n        datesToProcess.forEach(date => {\n          // Check if an entry for this recurring payment already exists on this date\n          const entryExists = entries.some(entry => \n            isSameDay(entry.date, date) && \n            entry.description === `[Recurring] ${payment.description}`\n          );\n\n          if (!entryExists) {\n            // Create a new entry for this recurring payment\n            newEntries.push({\n              id: uuidv4(),\n              date: new Date(date),\n              amount: payment.amount,\n              description: `[Recurring] ${payment.description}`,\n              type: payment.type\n            });\n          }\n        });\n      });\n\n      // Add new entries if any were generated\n      if (newEntries.length > 0) {\n        setEntries(prevEntries => [...prevEntries, ...newEntries]);\n      }\n    };\n\n    // Process recurring payments\n    if (recurringPayments.length > 0) {\n      processRecurringPayments();\n    }\n  }, [recurringPayments, entries, currentDate]);\n\n  // Calculate month data\n  const monthData = useMemo(() => {\n    const startDate = startOfMonth(currentDate);\n    const endDate = endOfMonth(currentDate);\n    const daysInMonth = eachDayOfInterval({ start: startDate, end: endDate });\n\n    const days = daysInMonth.reduce((acc, day) => {\n      const formattedDate = format(day, 'yyyy-MM-dd');\n      const dayEntries = entries.filter(entry => isSameDay(entry.date, day));\n      \n      const totalIncome = dayEntries\n        .filter(entry => entry.type === 'income')\n        .reduce((sum, entry) => sum + entry.amount, 0);\n      \n      const totalExpenses = dayEntries\n        .filter(entry => entry.type === 'expense')\n        .reduce((sum, entry) => sum + entry.amount, 0);\n\n      acc[formattedDate] = {\n        date: day,\n        entries: dayEntries,\n        totalIncome,\n        totalExpenses,\n        dailyBalance: totalIncome - totalExpenses,\n        runningBalance: 0, // Calculated after all days are processed\n      };\n\n      return acc;\n    }, {} as Record<string, any>);\n\n    // Calculate running balance\n    let runningBalance = 0;\n    for (const day of daysInMonth) {\n      const formattedDate = format(day, 'yyyy-MM-dd');\n      runningBalance += days[formattedDate].dailyBalance;\n      days[formattedDate].runningBalance = runningBalance;\n    }\n\n    // Calculate total income, expenses, and balance for the month\n    const totalIncome = Object.values(days).reduce(\n      (sum, day: any) => sum + day.totalIncome,\n      0\n    );\n    const totalExpenses = Object.values(days).reduce(\n      (sum, day: any) => sum + day.totalExpenses,\n      0\n    );\n\n    return {\n      days,\n      totalIncome,\n      totalExpenses,\n      monthlyBalance: totalIncome - totalExpenses,\n    };\n  }, [currentDate, entries]);\n\n  // Calculate year data\n  const yearData = useMemo(() => {\n    const year = currentDate.getFullYear();\n    const months = Array.from({ length: 12 }, (_, i) => i);\n\n    const monthSummaries = months.map(month => {\n      const monthEntries = entries.filter(entry => \n        entry.date.getFullYear() === year && \n        entry.date.getMonth() === month\n      );\n\n      const totalIncome = monthEntries\n        .filter(entry => entry.type === 'income')\n        .reduce((sum, entry) => sum + entry.amount, 0);\n      \n      const totalExpenses = monthEntries\n        .filter(entry => entry.type === 'expense')\n        .reduce((sum, entry) => sum + entry.amount, 0);\n\n      return {\n        month,\n        year,\n        totalIncome,\n        totalExpenses,\n        monthlyBalance: totalIncome - totalExpenses,\n      };\n    });\n\n    const totalIncome = monthSummaries.reduce(\n      (sum, month) => sum + month.totalIncome,\n      0\n    );\n    const totalExpenses = monthSummaries.reduce(\n      (sum, month) => sum + month.totalExpenses,\n      0\n    );\n\n    return {\n      year,\n      months: monthSummaries,\n      totalIncome,\n      totalExpenses,\n      yearlyBalance: totalIncome - totalExpenses,\n    };\n  }, [currentDate, entries]);\n\n  // Add a new financial entry\n  const addEntry = (entry: Omit<FinancialEntry, 'id'>) => {\n    const newEntry = {\n      ...entry,\n      id: uuidv4(),\n    };\n    setEntries(prevEntries => [...prevEntries, newEntry]);\n  };\n\n  // Update an existing financial entry\n  const updateEntry = (updatedEntry: FinancialEntry) => {\n    setEntries(prevEntries =>\n      prevEntries.map(entry => \n        entry.id === updatedEntry.id ? updatedEntry : entry\n      )\n    );\n  };\n\n  // Delete a financial entry\n  const deleteEntry = (id: string) => {\n    setEntries(prevEntries => prevEntries.filter(entry => entry.id !== id));\n  };\n\n  // Add a new recurring payment\n  const addRecurringPayment = (payment: Omit<RecurringPayment, 'id'>) => {\n    const newPayment = {\n      ...payment,\n      id: uuidv4(),\n    };\n    \n    // Immediately process this new payment to create entries\n    const today = new Date();\n    today.setHours(0, 0, 0, 0);\n    \n    // Selected month in the UI\n    const selectedMonthStart = startOfMonth(currentDate);\n    const selectedMonthEnd = endOfMonth(currentDate);\n    \n    // The end date should be the later of today's month end or the selected month end\n    const endDate = new Date(\n      Math.max(\n        endOfMonth(today).getTime(),\n        selectedMonthEnd.getTime()\n      )\n    );\n    \n    let datesToProcess: Date[] = [];\n    \n    if (newPayment.isActive) {\n      // Get the earlier of the selected month start or today (for processing)\n      const startDate = new Date(Math.min(today.getTime(), selectedMonthStart.getTime()));\n      \n      // Check if the payment schedule is valid \n      const processingStart = new Date(Math.max(newPayment.startDate.getTime(), startDate.getTime()));\n      const processingEnd = newPayment.endDate && isBefore(newPayment.endDate, endDate) \n        ? newPayment.endDate \n        : endDate;\n      \n      if (!isAfter(processingStart, processingEnd)) {\n        // Get dates based on schedule type\n        switch (newPayment.scheduleType) {\n          case 'specific-date':\n            if (newPayment.frequency === 'monthly' && newPayment.dayOfMonth) {\n              const allDays = eachDayOfInterval({ start: processingStart, end: processingEnd });\n              datesToProcess = allDays.filter(date => getDate(date) === newPayment.dayOfMonth);\n            } else if (newPayment.frequency === 'yearly' && newPayment.dayOfMonth) {\n              const allDays = eachDayOfInterval({ start: processingStart, end: processingEnd });\n              datesToProcess = allDays.filter(date => \n                getDate(date) === newPayment.dayOfMonth &&\n                date.getMonth() === newPayment.startDate.getMonth()\n              );\n            }\n            break;\n          case 'weekdays-only':\n            datesToProcess = eachDayOfInterval({ start: processingStart, end: processingEnd })\n              .filter(date => !isWeekend(date));\n            break;\n          case 'weekends-only':\n            datesToProcess = eachDayOfInterval({ start: processingStart, end: processingEnd })\n              .filter(date => isWeekend(date));\n            break;\n          case 'custom-range':\n            datesToProcess = eachDayOfInterval({ start: processingStart, end: processingEnd });\n            \n            switch (newPayment.frequency) {\n              case 'daily':\n                break;\n              case 'weekly':\n                datesToProcess = datesToProcess.filter(date => \n                  date.getDay() === newPayment.startDate.getDay()\n                );\n                break;\n              case 'monthly':\n                datesToProcess = datesToProcess.filter(date => \n                  getDate(date) === getDate(newPayment.startDate)\n                );\n                break;\n              case 'yearly':\n                datesToProcess = datesToProcess.filter(date => \n                  getDate(date) === getDate(newPayment.startDate) && \n                  date.getMonth() === newPayment.startDate.getMonth()\n                );\n                break;\n            }\n            break;\n        }\n        \n        // Create entries for dates\n        const newEntries: FinancialEntry[] = datesToProcess.map(date => ({\n          id: uuidv4(),\n          date: new Date(date),\n          amount: newPayment.amount,\n          description: `[Recurring] ${newPayment.description}`,\n          type: newPayment.type\n        }));\n        \n        if (newEntries.length > 0) {\n          setEntries(prevEntries => [...prevEntries, ...newEntries]);\n        }\n      }\n    }\n    \n    setRecurringPayments(prevPayments => [...prevPayments, newPayment]);\n  };\n\n  // Update an existing recurring payment\n  const updateRecurringPayment = (updatedPayment: RecurringPayment) => {\n    // Get the existing payment to compare descriptions\n    const existingPayment = recurringPayments.find(p => p.id === updatedPayment.id);\n    if (!existingPayment) return;\n\n    // First, remove all existing entries for this recurring payment\n    setEntries(prevEntries => \n      prevEntries.filter(entry => \n        !entry.description.startsWith(`[Recurring] ${existingPayment.description}`)\n      )\n    );\n\n    // Update the recurring payment\n    setRecurringPayments(prevPayments =>\n      prevPayments.map(payment =>\n        payment.id === updatedPayment.id ? updatedPayment : payment\n      )\n    );\n\n    // If the payment is active, process it immediately to create new entries\n    if (updatedPayment.isActive) {\n      const today = new Date();\n      today.setHours(0, 0, 0, 0);\n      \n      const selectedMonthStart = startOfMonth(currentDate);\n      const selectedMonthEnd = endOfMonth(currentDate);\n      \n      const endDate = new Date(\n        Math.max(\n          endOfMonth(today).getTime(),\n          selectedMonthEnd.getTime()\n        )\n      );\n      \n      let datesToProcess: Date[] = [];\n      const startDate = new Date(Math.min(today.getTime(), selectedMonthStart.getTime()));\n      \n      const processingStart = new Date(Math.max(updatedPayment.startDate.getTime(), startDate.getTime()));\n      const processingEnd = updatedPayment.endDate && isBefore(updatedPayment.endDate, endDate) \n        ? updatedPayment.endDate \n        : endDate;\n      \n      if (!isAfter(processingStart, processingEnd)) {\n        switch (updatedPayment.scheduleType) {\n          case 'specific-date':\n            if (updatedPayment.frequency === 'monthly' && updatedPayment.dayOfMonth) {\n              const allDays = eachDayOfInterval({ start: processingStart, end: processingEnd });\n              datesToProcess = allDays.filter(date => getDate(date) === updatedPayment.dayOfMonth);\n            } else if (updatedPayment.frequency === 'yearly' && updatedPayment.dayOfMonth) {\n              const allDays = eachDayOfInterval({ start: processingStart, end: processingEnd });\n              datesToProcess = allDays.filter(date => \n                getDate(date) === updatedPayment.dayOfMonth &&\n                date.getMonth() === updatedPayment.startDate.getMonth()\n              );\n            }\n            break;\n          case 'weekdays-only':\n            datesToProcess = eachDayOfInterval({ start: processingStart, end: processingEnd })\n              .filter(date => !isWeekend(date));\n            break;\n          case 'weekends-only':\n            datesToProcess = eachDayOfInterval({ start: processingStart, end: processingEnd })\n              .filter(date => isWeekend(date));\n            break;\n          case 'custom-range':\n            datesToProcess = eachDayOfInterval({ start: processingStart, end: processingEnd });\n            \n            switch (updatedPayment.frequency) {\n              case 'daily':\n                break;\n              case 'weekly':\n                datesToProcess = datesToProcess.filter(date => \n                  date.getDay() === updatedPayment.startDate.getDay()\n                );\n                break;\n              case 'monthly':\n                datesToProcess = datesToProcess.filter(date => \n                  getDate(date) === getDate(updatedPayment.startDate)\n                );\n                break;\n              case 'yearly':\n                datesToProcess = datesToProcess.filter(date => \n                  getDate(date) === getDate(updatedPayment.startDate) && \n                  date.getMonth() === updatedPayment.startDate.getMonth()\n                );\n                break;\n            }\n            break;\n        }\n        \n        // Create new entries for the updated payment\n        const newEntries: FinancialEntry[] = datesToProcess.map(date => ({\n          id: uuidv4(),\n          date: new Date(date),\n          amount: updatedPayment.amount,\n          description: `[Recurring] ${updatedPayment.description}`,\n          type: updatedPayment.type\n        }));\n        \n        if (newEntries.length > 0) {\n          setEntries(prevEntries => [...prevEntries, ...newEntries]);\n        }\n      }\n    }\n  };\n\n  // Delete a recurring payment\n  const deleteRecurringPayment = (id: string) => {\n    // Get the payment before deleting it\n    const paymentToDelete = recurringPayments.find(payment => payment.id === id);\n    \n    if (paymentToDelete) {\n      // Remove all entries associated with this recurring payment\n      setEntries(prevEntries => \n        prevEntries.filter(entry => \n          !entry.description.startsWith(`[Recurring] ${paymentToDelete.description}`)\n        )\n      );\n    }\n    \n    // Remove the recurring payment\n    setRecurringPayments(prevPayments => \n      prevPayments.filter(payment => payment.id !== id)\n    );\n  };\n\n  return {\n    entries,\n    addEntry,\n    updateEntry,\n    deleteEntry,\n    recurringPayments,\n    addRecurringPayment,\n    updateRecurringPayment,\n    deleteRecurringPayment,\n    monthData,\n    yearData,\n  };\n}; "],"mappings":";AAAA,SAASA,QAAQ,EAAEC,SAAS,EAAEC,OAAO,EAAEC,WAAW,QAAQ,OAAO;AAKjE,SAASC,EAAE,IAAIC,MAAM,QAAQ,MAAM;AACnC,SACEC,MAAM,EACNC,YAAY,EACZC,UAAU,EACVC,iBAAiB,EACjBC,OAAO,EACPC,QAAQ,EACRC,SAAS,EACTC,SAAS,EACTC,OAAO,QACF,UAAU;AACjB,SAASC,OAAO,QAAQ,wBAAwB;AAEhD,MAAMC,mBAAmB,GAAG,iCAAiC;AAC7D,MAAMC,8BAA8B,GAAG,4CAA4C;;AAEnF;AACA,MAAMC,WAAW,GAAGA,CAACC,GAAW,EAAEC,KAAU,KAAK;EAC/C,IAAID,GAAG,KAAK,MAAM,IAAIA,GAAG,KAAK,WAAW,IAAIA,GAAG,KAAK,SAAS,EAAE;IAC9D,OAAO,IAAIE,IAAI,CAACD,KAAK,CAAC;EACxB;EACA,OAAOA,KAAK;AACd,CAAC;AAED,OAAO,MAAME,gBAAgB,GAAGA,CAACC,WAAiB,GAAG,IAAIF,IAAI,CAAC,CAAC,KAAK;EAAAG,EAAA;EAClE,MAAM;IAAEC;EAAY,CAAC,GAAGV,OAAO,CAAC,CAAC;EACjC,MAAM,CAACW,OAAO,EAAEC,UAAU,CAAC,GAAG3B,QAAQ,CAAmB,EAAE,CAAC;EAC5D,MAAM,CAAC4B,iBAAiB,EAAEC,oBAAoB,CAAC,GAAG7B,QAAQ,CAAqB,EAAE,CAAC;;EAElF;EACA,MAAM8B,aAAa,GAAG3B,WAAW,CAAEgB,GAAW,IAAK;IACjD,OAAOM,WAAW,GACd,GAAGN,GAAG,IAAIM,WAAW,CAACM,EAAE,EAAE,GAC1BZ,GAAG;EACT,CAAC,EAAE,CAACM,WAAW,CAAC,CAAC;;EAEjB;EACAxB,SAAS,CAAC,MAAM;IACd,MAAM+B,YAAY,GAAGC,YAAY,CAACC,OAAO,CAACJ,aAAa,CAACd,mBAAmB,CAAC,CAAC;IAC7E,IAAIgB,YAAY,EAAE;MAChB,MAAMG,aAAa,GAAGC,IAAI,CAACC,KAAK,CAACL,YAAY,EAAEd,WAAW,CAAC;MAC3DS,UAAU,CAACQ,aAAa,CAACG,GAAG,CAAEC,KAAU,KAAM;QAC5C,GAAGA,KAAK;QACRC,IAAI,EAAE,IAAInB,IAAI,CAACkB,KAAK,CAACC,IAAI;MAC3B,CAAC,CAAC,CAAC,CAAC;IACN;EACF,CAAC,EAAE,CAACV,aAAa,CAAC,CAAC;;EAEnB;EACA7B,SAAS,CAAC,MAAM;IACd,IAAIyB,OAAO,CAACe,MAAM,GAAG,CAAC,EAAE;MACtBR,YAAY,CAACS,OAAO,CAACZ,aAAa,CAACd,mBAAmB,CAAC,EAAEoB,IAAI,CAACO,SAAS,CAACjB,OAAO,CAAC,CAAC;IACnF;EACF,CAAC,EAAE,CAACA,OAAO,EAAEI,aAAa,CAAC,CAAC;;EAE5B;EACA7B,SAAS,CAAC,MAAM;IACd,MAAM2C,sBAAsB,GAAGX,YAAY,CAACC,OAAO,CAACJ,aAAa,CAACb,8BAA8B,CAAC,CAAC;IAClG,IAAI2B,sBAAsB,EAAE;MAC1B,MAAMC,cAAc,GAAGT,IAAI,CAACC,KAAK,CAACO,sBAAsB,EAAE1B,WAAW,CAAC;MACtEW,oBAAoB,CAACgB,cAAc,CAACP,GAAG,CAAEQ,OAAY,KAAM;QACzD,GAAGA,OAAO;QACVC,SAAS,EAAE,IAAI1B,IAAI,CAACyB,OAAO,CAACC,SAAS,CAAC;QACtCC,OAAO,EAAEF,OAAO,CAACE,OAAO,GAAG,IAAI3B,IAAI,CAACyB,OAAO,CAACE,OAAO,CAAC,GAAGC,SAAS;QAChEC,SAAS,EAAE,IAAI7B,IAAI,CAACyB,OAAO,CAACI,SAAS,CAAC;QACtCC,UAAU,EAAEL,OAAO,CAACK,UAAU,GAAG,IAAI9B,IAAI,CAACyB,OAAO,CAACK,UAAU,CAAC,GAAGF;MAClE,CAAC,CAAC,CAAC,CAAC;IACN;EACF,CAAC,EAAE,CAACnB,aAAa,CAAC,CAAC;;EAEnB;EACA7B,SAAS,CAAC,MAAM;IACd,IAAI2B,iBAAiB,CAACa,MAAM,GAAG,CAAC,EAAE;MAChCR,YAAY,CAACS,OAAO,CAACZ,aAAa,CAACb,8BAA8B,CAAC,EAAEmB,IAAI,CAACO,SAAS,CAACf,iBAAiB,CAAC,CAAC;IACxG;EACF,CAAC,EAAE,CAACA,iBAAiB,EAAEE,aAAa,CAAC,CAAC;;EAEtC;EACA7B,SAAS,CAAC,MAAM;IACd,MAAMmD,wBAAwB,GAAGA,CAAA,KAAM;MACrC;MACA,MAAMC,KAAK,GAAG,IAAIhC,IAAI,CAAC,CAAC;MACxBgC,KAAK,CAACC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;;MAE1B;MACA,MAAMC,kBAAkB,GAAGhD,YAAY,CAACgB,WAAW,CAAC;MACpD,MAAMiC,gBAAgB,GAAGhD,UAAU,CAACe,WAAW,CAAC;;MAEhD;MACA,MAAMkC,kBAAkB,GAAG,IAAIpC,IAAI,CAACgC,KAAK,CAAC;MAC1CI,kBAAkB,CAACC,OAAO,CAACD,kBAAkB,CAAC3C,OAAO,CAAC,CAAC,GAAG,EAAE,CAAC;;MAE7D;MACA;MACA;MACA,MAAMiC,SAAS,GAAG,IAAI1B,IAAI,CAACsC,IAAI,CAACC,GAAG,CAACH,kBAAkB,CAACI,OAAO,CAAC,CAAC,EAAEN,kBAAkB,CAACM,OAAO,CAAC,CAAC,CAAC,CAAC;;MAEhG;MACA;MACA;MACA,MAAMb,OAAO,GAAG,IAAI3B,IAAI,CACtBsC,IAAI,CAACG,GAAG,CACNtD,UAAU,CAAC6C,KAAK,CAAC,CAACQ,OAAO,CAAC,CAAC,EAC3BL,gBAAgB,CAACK,OAAO,CAAC,CAC3B,CACF,CAAC;;MAED;MACA,MAAME,UAA4B,GAAG,EAAE;;MAEvC;MACAnC,iBAAiB,CAACoC,OAAO,CAAClB,OAAO,IAAI;QACnC,IAAI,CAACA,OAAO,CAACmB,QAAQ,EAAE;;QAEvB;QACA,MAAMC,cAAc,GAAGpB,OAAO,CAACK,UAAU,IAAI,IAAI9B,IAAI,CAAC,IAAI,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC,CAAC;;QAErE;QACA,IAAIX,OAAO,CAACoC,OAAO,CAACI,SAAS,EAAEF,OAAO,CAAC,IAAIrC,QAAQ,CAACuD,cAAc,EAAEnB,SAAS,CAAC,EAAE;UAC9E;QACF;;QAEA;QACA,IAAIoB,cAAsB,GAAG,EAAE;;QAE/B;QACA,MAAMC,eAAe,GAAG,IAAI/C,IAAI,CAACsC,IAAI,CAACG,GAAG,CAAChB,OAAO,CAACC,SAAS,CAACc,OAAO,CAAC,CAAC,EAAEd,SAAS,CAACc,OAAO,CAAC,CAAC,CAAC,CAAC;;QAE5F;QACA,MAAMQ,aAAa,GAAGvB,OAAO,CAACE,OAAO,IAAIrC,QAAQ,CAACmC,OAAO,CAACE,OAAO,EAAEA,OAAO,CAAC,GACvEF,OAAO,CAACE,OAAO,GACfA,OAAO;;QAEX;QACA,IAAItC,OAAO,CAAC0D,eAAe,EAAEC,aAAa,CAAC,EAAE;;QAE7C;QACA,QAAQvB,OAAO,CAACwB,YAAY;UAC1B,KAAK,eAAe;YAClB;YACA,IAAIxB,OAAO,CAACyB,SAAS,KAAK,SAAS,IAAIzB,OAAO,CAAC0B,UAAU,EAAE;cACzD;cACA,MAAMC,OAAO,GAAGhE,iBAAiB,CAAC;gBAAEiE,KAAK,EAAEN,eAAe;gBAAEO,GAAG,EAAEN;cAAc,CAAC,CAAC;cACjF;cACAF,cAAc,GAAGM,OAAO,CAACG,MAAM,CAACpC,IAAI,IAAI1B,OAAO,CAAC0B,IAAI,CAAC,KAAKM,OAAO,CAAC0B,UAAU,CAAC;YAC/E;YACA;YAAA,KACK,IAAI1B,OAAO,CAACyB,SAAS,KAAK,QAAQ,IAAIzB,OAAO,CAAC0B,UAAU,EAAE;cAC7D;cACA,MAAMC,OAAO,GAAGhE,iBAAiB,CAAC;gBAAEiE,KAAK,EAAEN,eAAe;gBAAEO,GAAG,EAAEN;cAAc,CAAC,CAAC;cACjF;cACAF,cAAc,GAAGM,OAAO,CAACG,MAAM,CAACpC,IAAI,IAClC1B,OAAO,CAAC0B,IAAI,CAAC,KAAKM,OAAO,CAAC0B,UAAU,IACpChC,IAAI,CAACqC,QAAQ,CAAC,CAAC,KAAK/B,OAAO,CAACC,SAAS,CAAC8B,QAAQ,CAAC,CACjD,CAAC;YACH;YACA;UAEF,KAAK,eAAe;YAClB;YACAV,cAAc,GAAG1D,iBAAiB,CAAC;cAAEiE,KAAK,EAAEN,eAAe;cAAEO,GAAG,EAAEN;YAAc,CAAC,CAAC,CAC/EO,MAAM,CAACpC,IAAI,IAAI,CAAC3B,SAAS,CAAC2B,IAAI,CAAC,CAAC;YACnC;UAEF,KAAK,eAAe;YAClB;YACA2B,cAAc,GAAG1D,iBAAiB,CAAC;cAAEiE,KAAK,EAAEN,eAAe;cAAEO,GAAG,EAAEN;YAAc,CAAC,CAAC,CAC/EO,MAAM,CAACpC,IAAI,IAAI3B,SAAS,CAAC2B,IAAI,CAAC,CAAC;YAClC;UAEF,KAAK,cAAc;YACjB;YACA2B,cAAc,GAAG1D,iBAAiB,CAAC;cAAEiE,KAAK,EAAEN,eAAe;cAAEO,GAAG,EAAEN;YAAc,CAAC,CAAC;;YAElF;YACA,QAAQvB,OAAO,CAACyB,SAAS;cACvB,KAAK,OAAO;gBACV;gBACA;cAEF,KAAK,QAAQ;gBACX;gBACAJ,cAAc,GAAGA,cAAc,CAACS,MAAM,CAACpC,IAAI,IACzCA,IAAI,CAACsC,MAAM,CAAC,CAAC,KAAKhC,OAAO,CAACC,SAAS,CAAC+B,MAAM,CAAC,CAC7C,CAAC;gBACD;cAEF,KAAK,SAAS;gBACZ;gBACAX,cAAc,GAAGA,cAAc,CAACS,MAAM,CAACpC,IAAI,IACzC1B,OAAO,CAAC0B,IAAI,CAAC,KAAK1B,OAAO,CAACgC,OAAO,CAACC,SAAS,CAC7C,CAAC;gBACD;cAEF,KAAK,QAAQ;gBACX;gBACAoB,cAAc,GAAGA,cAAc,CAACS,MAAM,CAACpC,IAAI,IACzC1B,OAAO,CAAC0B,IAAI,CAAC,KAAK1B,OAAO,CAACgC,OAAO,CAACC,SAAS,CAAC,IAC5CP,IAAI,CAACqC,QAAQ,CAAC,CAAC,KAAK/B,OAAO,CAACC,SAAS,CAAC8B,QAAQ,CAAC,CACjD,CAAC;gBACD;YACJ;YACA;QACJ;;QAEA;QACAV,cAAc,CAACH,OAAO,CAACxB,IAAI,IAAI;UAC7B;UACA,MAAMuC,WAAW,GAAGrD,OAAO,CAACsD,IAAI,CAACzC,KAAK,IACpC3B,SAAS,CAAC2B,KAAK,CAACC,IAAI,EAAEA,IAAI,CAAC,IAC3BD,KAAK,CAAC0C,WAAW,KAAK,eAAenC,OAAO,CAACmC,WAAW,EAC1D,CAAC;UAED,IAAI,CAACF,WAAW,EAAE;YAChB;YACAhB,UAAU,CAACmB,IAAI,CAAC;cACdnD,EAAE,EAAE1B,MAAM,CAAC,CAAC;cACZmC,IAAI,EAAE,IAAInB,IAAI,CAACmB,IAAI,CAAC;cACpB2C,MAAM,EAAErC,OAAO,CAACqC,MAAM;cACtBF,WAAW,EAAE,eAAenC,OAAO,CAACmC,WAAW,EAAE;cACjDG,IAAI,EAAEtC,OAAO,CAACsC;YAChB,CAAC,CAAC;UACJ;QACF,CAAC,CAAC;MACJ,CAAC,CAAC;;MAEF;MACA,IAAIrB,UAAU,CAACtB,MAAM,GAAG,CAAC,EAAE;QACzBd,UAAU,CAAC0D,WAAW,IAAI,CAAC,GAAGA,WAAW,EAAE,GAAGtB,UAAU,CAAC,CAAC;MAC5D;IACF,CAAC;;IAED;IACA,IAAInC,iBAAiB,CAACa,MAAM,GAAG,CAAC,EAAE;MAChCW,wBAAwB,CAAC,CAAC;IAC5B;EACF,CAAC,EAAE,CAACxB,iBAAiB,EAAEF,OAAO,EAAEH,WAAW,CAAC,CAAC;;EAE7C;EACA,MAAM+D,SAAS,GAAGpF,OAAO,CAAC,MAAM;IAC9B,MAAM6C,SAAS,GAAGxC,YAAY,CAACgB,WAAW,CAAC;IAC3C,MAAMyB,OAAO,GAAGxC,UAAU,CAACe,WAAW,CAAC;IACvC,MAAMgE,WAAW,GAAG9E,iBAAiB,CAAC;MAAEiE,KAAK,EAAE3B,SAAS;MAAE4B,GAAG,EAAE3B;IAAQ,CAAC,CAAC;IAEzE,MAAMwC,IAAI,GAAGD,WAAW,CAACE,MAAM,CAAC,CAACC,GAAG,EAAEC,GAAG,KAAK;MAC5C,MAAMC,aAAa,GAAGtF,MAAM,CAACqF,GAAG,EAAE,YAAY,CAAC;MAC/C,MAAME,UAAU,GAAGnE,OAAO,CAACkD,MAAM,CAACrC,KAAK,IAAI3B,SAAS,CAAC2B,KAAK,CAACC,IAAI,EAAEmD,GAAG,CAAC,CAAC;MAEtE,MAAMG,WAAW,GAAGD,UAAU,CAC3BjB,MAAM,CAACrC,KAAK,IAAIA,KAAK,CAAC6C,IAAI,KAAK,QAAQ,CAAC,CACxCK,MAAM,CAAC,CAACM,GAAG,EAAExD,KAAK,KAAKwD,GAAG,GAAGxD,KAAK,CAAC4C,MAAM,EAAE,CAAC,CAAC;MAEhD,MAAMa,aAAa,GAAGH,UAAU,CAC7BjB,MAAM,CAACrC,KAAK,IAAIA,KAAK,CAAC6C,IAAI,KAAK,SAAS,CAAC,CACzCK,MAAM,CAAC,CAACM,GAAG,EAAExD,KAAK,KAAKwD,GAAG,GAAGxD,KAAK,CAAC4C,MAAM,EAAE,CAAC,CAAC;MAEhDO,GAAG,CAACE,aAAa,CAAC,GAAG;QACnBpD,IAAI,EAAEmD,GAAG;QACTjE,OAAO,EAAEmE,UAAU;QACnBC,WAAW;QACXE,aAAa;QACbC,YAAY,EAAEH,WAAW,GAAGE,aAAa;QACzCE,cAAc,EAAE,CAAC,CAAE;MACrB,CAAC;MAED,OAAOR,GAAG;IACZ,CAAC,EAAE,CAAC,CAAwB,CAAC;;IAE7B;IACA,IAAIQ,cAAc,GAAG,CAAC;IACtB,KAAK,MAAMP,GAAG,IAAIJ,WAAW,EAAE;MAC7B,MAAMK,aAAa,GAAGtF,MAAM,CAACqF,GAAG,EAAE,YAAY,CAAC;MAC/CO,cAAc,IAAIV,IAAI,CAACI,aAAa,CAAC,CAACK,YAAY;MAClDT,IAAI,CAACI,aAAa,CAAC,CAACM,cAAc,GAAGA,cAAc;IACrD;;IAEA;IACA,MAAMJ,WAAW,GAAGK,MAAM,CAACC,MAAM,CAACZ,IAAI,CAAC,CAACC,MAAM,CAC5C,CAACM,GAAG,EAAEJ,GAAQ,KAAKI,GAAG,GAAGJ,GAAG,CAACG,WAAW,EACxC,CACF,CAAC;IACD,MAAME,aAAa,GAAGG,MAAM,CAACC,MAAM,CAACZ,IAAI,CAAC,CAACC,MAAM,CAC9C,CAACM,GAAG,EAAEJ,GAAQ,KAAKI,GAAG,GAAGJ,GAAG,CAACK,aAAa,EAC1C,CACF,CAAC;IAED,OAAO;MACLR,IAAI;MACJM,WAAW;MACXE,aAAa;MACbK,cAAc,EAAEP,WAAW,GAAGE;IAChC,CAAC;EACH,CAAC,EAAE,CAACzE,WAAW,EAAEG,OAAO,CAAC,CAAC;;EAE1B;EACA,MAAM4E,QAAQ,GAAGpG,OAAO,CAAC,MAAM;IAC7B,MAAMqG,IAAI,GAAGhF,WAAW,CAACiF,WAAW,CAAC,CAAC;IACtC,MAAMC,MAAM,GAAGC,KAAK,CAACC,IAAI,CAAC;MAAElE,MAAM,EAAE;IAAG,CAAC,EAAE,CAACmE,CAAC,EAAEC,CAAC,KAAKA,CAAC,CAAC;IAEtD,MAAMC,cAAc,GAAGL,MAAM,CAACnE,GAAG,CAACyE,KAAK,IAAI;MACzC,MAAMC,YAAY,GAAGtF,OAAO,CAACkD,MAAM,CAACrC,KAAK,IACvCA,KAAK,CAACC,IAAI,CAACgE,WAAW,CAAC,CAAC,KAAKD,IAAI,IACjChE,KAAK,CAACC,IAAI,CAACqC,QAAQ,CAAC,CAAC,KAAKkC,KAC5B,CAAC;MAED,MAAMjB,WAAW,GAAGkB,YAAY,CAC7BpC,MAAM,CAACrC,KAAK,IAAIA,KAAK,CAAC6C,IAAI,KAAK,QAAQ,CAAC,CACxCK,MAAM,CAAC,CAACM,GAAG,EAAExD,KAAK,KAAKwD,GAAG,GAAGxD,KAAK,CAAC4C,MAAM,EAAE,CAAC,CAAC;MAEhD,MAAMa,aAAa,GAAGgB,YAAY,CAC/BpC,MAAM,CAACrC,KAAK,IAAIA,KAAK,CAAC6C,IAAI,KAAK,SAAS,CAAC,CACzCK,MAAM,CAAC,CAACM,GAAG,EAAExD,KAAK,KAAKwD,GAAG,GAAGxD,KAAK,CAAC4C,MAAM,EAAE,CAAC,CAAC;MAEhD,OAAO;QACL4B,KAAK;QACLR,IAAI;QACJT,WAAW;QACXE,aAAa;QACbK,cAAc,EAAEP,WAAW,GAAGE;MAChC,CAAC;IACH,CAAC,CAAC;IAEF,MAAMF,WAAW,GAAGgB,cAAc,CAACrB,MAAM,CACvC,CAACM,GAAG,EAAEgB,KAAK,KAAKhB,GAAG,GAAGgB,KAAK,CAACjB,WAAW,EACvC,CACF,CAAC;IACD,MAAME,aAAa,GAAGc,cAAc,CAACrB,MAAM,CACzC,CAACM,GAAG,EAAEgB,KAAK,KAAKhB,GAAG,GAAGgB,KAAK,CAACf,aAAa,EACzC,CACF,CAAC;IAED,OAAO;MACLO,IAAI;MACJE,MAAM,EAAEK,cAAc;MACtBhB,WAAW;MACXE,aAAa;MACbiB,aAAa,EAAEnB,WAAW,GAAGE;IAC/B,CAAC;EACH,CAAC,EAAE,CAACzE,WAAW,EAAEG,OAAO,CAAC,CAAC;;EAE1B;EACA,MAAMwF,QAAQ,GAAI3E,KAAiC,IAAK;IACtD,MAAM4E,QAAQ,GAAG;MACf,GAAG5E,KAAK;MACRR,EAAE,EAAE1B,MAAM,CAAC;IACb,CAAC;IACDsB,UAAU,CAAC0D,WAAW,IAAI,CAAC,GAAGA,WAAW,EAAE8B,QAAQ,CAAC,CAAC;EACvD,CAAC;;EAED;EACA,MAAMC,WAAW,GAAIC,YAA4B,IAAK;IACpD1F,UAAU,CAAC0D,WAAW,IACpBA,WAAW,CAAC/C,GAAG,CAACC,KAAK,IACnBA,KAAK,CAACR,EAAE,KAAKsF,YAAY,CAACtF,EAAE,GAAGsF,YAAY,GAAG9E,KAChD,CACF,CAAC;EACH,CAAC;;EAED;EACA,MAAM+E,WAAW,GAAIvF,EAAU,IAAK;IAClCJ,UAAU,CAAC0D,WAAW,IAAIA,WAAW,CAACT,MAAM,CAACrC,KAAK,IAAIA,KAAK,CAACR,EAAE,KAAKA,EAAE,CAAC,CAAC;EACzE,CAAC;;EAED;EACA,MAAMwF,mBAAmB,GAAIzE,OAAqC,IAAK;IACrE,MAAM0E,UAAU,GAAG;MACjB,GAAG1E,OAAO;MACVf,EAAE,EAAE1B,MAAM,CAAC;IACb,CAAC;;IAED;IACA,MAAMgD,KAAK,GAAG,IAAIhC,IAAI,CAAC,CAAC;IACxBgC,KAAK,CAACC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;;IAE1B;IACA,MAAMC,kBAAkB,GAAGhD,YAAY,CAACgB,WAAW,CAAC;IACpD,MAAMiC,gBAAgB,GAAGhD,UAAU,CAACe,WAAW,CAAC;;IAEhD;IACA,MAAMyB,OAAO,GAAG,IAAI3B,IAAI,CACtBsC,IAAI,CAACG,GAAG,CACNtD,UAAU,CAAC6C,KAAK,CAAC,CAACQ,OAAO,CAAC,CAAC,EAC3BL,gBAAgB,CAACK,OAAO,CAAC,CAC3B,CACF,CAAC;IAED,IAAIM,cAAsB,GAAG,EAAE;IAE/B,IAAIqD,UAAU,CAACvD,QAAQ,EAAE;MACvB;MACA,MAAMlB,SAAS,GAAG,IAAI1B,IAAI,CAACsC,IAAI,CAACC,GAAG,CAACP,KAAK,CAACQ,OAAO,CAAC,CAAC,EAAEN,kBAAkB,CAACM,OAAO,CAAC,CAAC,CAAC,CAAC;;MAEnF;MACA,MAAMO,eAAe,GAAG,IAAI/C,IAAI,CAACsC,IAAI,CAACG,GAAG,CAAC0D,UAAU,CAACzE,SAAS,CAACc,OAAO,CAAC,CAAC,EAAEd,SAAS,CAACc,OAAO,CAAC,CAAC,CAAC,CAAC;MAC/F,MAAMQ,aAAa,GAAGmD,UAAU,CAACxE,OAAO,IAAIrC,QAAQ,CAAC6G,UAAU,CAACxE,OAAO,EAAEA,OAAO,CAAC,GAC7EwE,UAAU,CAACxE,OAAO,GAClBA,OAAO;MAEX,IAAI,CAACtC,OAAO,CAAC0D,eAAe,EAAEC,aAAa,CAAC,EAAE;QAC5C;QACA,QAAQmD,UAAU,CAAClD,YAAY;UAC7B,KAAK,eAAe;YAClB,IAAIkD,UAAU,CAACjD,SAAS,KAAK,SAAS,IAAIiD,UAAU,CAAChD,UAAU,EAAE;cAC/D,MAAMC,OAAO,GAAGhE,iBAAiB,CAAC;gBAAEiE,KAAK,EAAEN,eAAe;gBAAEO,GAAG,EAAEN;cAAc,CAAC,CAAC;cACjFF,cAAc,GAAGM,OAAO,CAACG,MAAM,CAACpC,IAAI,IAAI1B,OAAO,CAAC0B,IAAI,CAAC,KAAKgF,UAAU,CAAChD,UAAU,CAAC;YAClF,CAAC,MAAM,IAAIgD,UAAU,CAACjD,SAAS,KAAK,QAAQ,IAAIiD,UAAU,CAAChD,UAAU,EAAE;cACrE,MAAMC,OAAO,GAAGhE,iBAAiB,CAAC;gBAAEiE,KAAK,EAAEN,eAAe;gBAAEO,GAAG,EAAEN;cAAc,CAAC,CAAC;cACjFF,cAAc,GAAGM,OAAO,CAACG,MAAM,CAACpC,IAAI,IAClC1B,OAAO,CAAC0B,IAAI,CAAC,KAAKgF,UAAU,CAAChD,UAAU,IACvChC,IAAI,CAACqC,QAAQ,CAAC,CAAC,KAAK2C,UAAU,CAACzE,SAAS,CAAC8B,QAAQ,CAAC,CACpD,CAAC;YACH;YACA;UACF,KAAK,eAAe;YAClBV,cAAc,GAAG1D,iBAAiB,CAAC;cAAEiE,KAAK,EAAEN,eAAe;cAAEO,GAAG,EAAEN;YAAc,CAAC,CAAC,CAC/EO,MAAM,CAACpC,IAAI,IAAI,CAAC3B,SAAS,CAAC2B,IAAI,CAAC,CAAC;YACnC;UACF,KAAK,eAAe;YAClB2B,cAAc,GAAG1D,iBAAiB,CAAC;cAAEiE,KAAK,EAAEN,eAAe;cAAEO,GAAG,EAAEN;YAAc,CAAC,CAAC,CAC/EO,MAAM,CAACpC,IAAI,IAAI3B,SAAS,CAAC2B,IAAI,CAAC,CAAC;YAClC;UACF,KAAK,cAAc;YACjB2B,cAAc,GAAG1D,iBAAiB,CAAC;cAAEiE,KAAK,EAAEN,eAAe;cAAEO,GAAG,EAAEN;YAAc,CAAC,CAAC;YAElF,QAAQmD,UAAU,CAACjD,SAAS;cAC1B,KAAK,OAAO;gBACV;cACF,KAAK,QAAQ;gBACXJ,cAAc,GAAGA,cAAc,CAACS,MAAM,CAACpC,IAAI,IACzCA,IAAI,CAACsC,MAAM,CAAC,CAAC,KAAK0C,UAAU,CAACzE,SAAS,CAAC+B,MAAM,CAAC,CAChD,CAAC;gBACD;cACF,KAAK,SAAS;gBACZX,cAAc,GAAGA,cAAc,CAACS,MAAM,CAACpC,IAAI,IACzC1B,OAAO,CAAC0B,IAAI,CAAC,KAAK1B,OAAO,CAAC0G,UAAU,CAACzE,SAAS,CAChD,CAAC;gBACD;cACF,KAAK,QAAQ;gBACXoB,cAAc,GAAGA,cAAc,CAACS,MAAM,CAACpC,IAAI,IACzC1B,OAAO,CAAC0B,IAAI,CAAC,KAAK1B,OAAO,CAAC0G,UAAU,CAACzE,SAAS,CAAC,IAC/CP,IAAI,CAACqC,QAAQ,CAAC,CAAC,KAAK2C,UAAU,CAACzE,SAAS,CAAC8B,QAAQ,CAAC,CACpD,CAAC;gBACD;YACJ;YACA;QACJ;;QAEA;QACA,MAAMd,UAA4B,GAAGI,cAAc,CAAC7B,GAAG,CAACE,IAAI,KAAK;UAC/DT,EAAE,EAAE1B,MAAM,CAAC,CAAC;UACZmC,IAAI,EAAE,IAAInB,IAAI,CAACmB,IAAI,CAAC;UACpB2C,MAAM,EAAEqC,UAAU,CAACrC,MAAM;UACzBF,WAAW,EAAE,eAAeuC,UAAU,CAACvC,WAAW,EAAE;UACpDG,IAAI,EAAEoC,UAAU,CAACpC;QACnB,CAAC,CAAC,CAAC;QAEH,IAAIrB,UAAU,CAACtB,MAAM,GAAG,CAAC,EAAE;UACzBd,UAAU,CAAC0D,WAAW,IAAI,CAAC,GAAGA,WAAW,EAAE,GAAGtB,UAAU,CAAC,CAAC;QAC5D;MACF;IACF;IAEAlC,oBAAoB,CAAC4F,YAAY,IAAI,CAAC,GAAGA,YAAY,EAAED,UAAU,CAAC,CAAC;EACrE,CAAC;;EAED;EACA,MAAME,sBAAsB,GAAIC,cAAgC,IAAK;IACnE;IACA,MAAMC,eAAe,GAAGhG,iBAAiB,CAACiG,IAAI,CAACC,CAAC,IAAIA,CAAC,CAAC/F,EAAE,KAAK4F,cAAc,CAAC5F,EAAE,CAAC;IAC/E,IAAI,CAAC6F,eAAe,EAAE;;IAEtB;IACAjG,UAAU,CAAC0D,WAAW,IACpBA,WAAW,CAACT,MAAM,CAACrC,KAAK,IACtB,CAACA,KAAK,CAAC0C,WAAW,CAAC8C,UAAU,CAAC,eAAeH,eAAe,CAAC3C,WAAW,EAAE,CAC5E,CACF,CAAC;;IAED;IACApD,oBAAoB,CAAC4F,YAAY,IAC/BA,YAAY,CAACnF,GAAG,CAACQ,OAAO,IACtBA,OAAO,CAACf,EAAE,KAAK4F,cAAc,CAAC5F,EAAE,GAAG4F,cAAc,GAAG7E,OACtD,CACF,CAAC;;IAED;IACA,IAAI6E,cAAc,CAAC1D,QAAQ,EAAE;MAC3B,MAAMZ,KAAK,GAAG,IAAIhC,IAAI,CAAC,CAAC;MACxBgC,KAAK,CAACC,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;MAE1B,MAAMC,kBAAkB,GAAGhD,YAAY,CAACgB,WAAW,CAAC;MACpD,MAAMiC,gBAAgB,GAAGhD,UAAU,CAACe,WAAW,CAAC;MAEhD,MAAMyB,OAAO,GAAG,IAAI3B,IAAI,CACtBsC,IAAI,CAACG,GAAG,CACNtD,UAAU,CAAC6C,KAAK,CAAC,CAACQ,OAAO,CAAC,CAAC,EAC3BL,gBAAgB,CAACK,OAAO,CAAC,CAC3B,CACF,CAAC;MAED,IAAIM,cAAsB,GAAG,EAAE;MAC/B,MAAMpB,SAAS,GAAG,IAAI1B,IAAI,CAACsC,IAAI,CAACC,GAAG,CAACP,KAAK,CAACQ,OAAO,CAAC,CAAC,EAAEN,kBAAkB,CAACM,OAAO,CAAC,CAAC,CAAC,CAAC;MAEnF,MAAMO,eAAe,GAAG,IAAI/C,IAAI,CAACsC,IAAI,CAACG,GAAG,CAAC6D,cAAc,CAAC5E,SAAS,CAACc,OAAO,CAAC,CAAC,EAAEd,SAAS,CAACc,OAAO,CAAC,CAAC,CAAC,CAAC;MACnG,MAAMQ,aAAa,GAAGsD,cAAc,CAAC3E,OAAO,IAAIrC,QAAQ,CAACgH,cAAc,CAAC3E,OAAO,EAAEA,OAAO,CAAC,GACrF2E,cAAc,CAAC3E,OAAO,GACtBA,OAAO;MAEX,IAAI,CAACtC,OAAO,CAAC0D,eAAe,EAAEC,aAAa,CAAC,EAAE;QAC5C,QAAQsD,cAAc,CAACrD,YAAY;UACjC,KAAK,eAAe;YAClB,IAAIqD,cAAc,CAACpD,SAAS,KAAK,SAAS,IAAIoD,cAAc,CAACnD,UAAU,EAAE;cACvE,MAAMC,OAAO,GAAGhE,iBAAiB,CAAC;gBAAEiE,KAAK,EAAEN,eAAe;gBAAEO,GAAG,EAAEN;cAAc,CAAC,CAAC;cACjFF,cAAc,GAAGM,OAAO,CAACG,MAAM,CAACpC,IAAI,IAAI1B,OAAO,CAAC0B,IAAI,CAAC,KAAKmF,cAAc,CAACnD,UAAU,CAAC;YACtF,CAAC,MAAM,IAAImD,cAAc,CAACpD,SAAS,KAAK,QAAQ,IAAIoD,cAAc,CAACnD,UAAU,EAAE;cAC7E,MAAMC,OAAO,GAAGhE,iBAAiB,CAAC;gBAAEiE,KAAK,EAAEN,eAAe;gBAAEO,GAAG,EAAEN;cAAc,CAAC,CAAC;cACjFF,cAAc,GAAGM,OAAO,CAACG,MAAM,CAACpC,IAAI,IAClC1B,OAAO,CAAC0B,IAAI,CAAC,KAAKmF,cAAc,CAACnD,UAAU,IAC3ChC,IAAI,CAACqC,QAAQ,CAAC,CAAC,KAAK8C,cAAc,CAAC5E,SAAS,CAAC8B,QAAQ,CAAC,CACxD,CAAC;YACH;YACA;UACF,KAAK,eAAe;YAClBV,cAAc,GAAG1D,iBAAiB,CAAC;cAAEiE,KAAK,EAAEN,eAAe;cAAEO,GAAG,EAAEN;YAAc,CAAC,CAAC,CAC/EO,MAAM,CAACpC,IAAI,IAAI,CAAC3B,SAAS,CAAC2B,IAAI,CAAC,CAAC;YACnC;UACF,KAAK,eAAe;YAClB2B,cAAc,GAAG1D,iBAAiB,CAAC;cAAEiE,KAAK,EAAEN,eAAe;cAAEO,GAAG,EAAEN;YAAc,CAAC,CAAC,CAC/EO,MAAM,CAACpC,IAAI,IAAI3B,SAAS,CAAC2B,IAAI,CAAC,CAAC;YAClC;UACF,KAAK,cAAc;YACjB2B,cAAc,GAAG1D,iBAAiB,CAAC;cAAEiE,KAAK,EAAEN,eAAe;cAAEO,GAAG,EAAEN;YAAc,CAAC,CAAC;YAElF,QAAQsD,cAAc,CAACpD,SAAS;cAC9B,KAAK,OAAO;gBACV;cACF,KAAK,QAAQ;gBACXJ,cAAc,GAAGA,cAAc,CAACS,MAAM,CAACpC,IAAI,IACzCA,IAAI,CAACsC,MAAM,CAAC,CAAC,KAAK6C,cAAc,CAAC5E,SAAS,CAAC+B,MAAM,CAAC,CACpD,CAAC;gBACD;cACF,KAAK,SAAS;gBACZX,cAAc,GAAGA,cAAc,CAACS,MAAM,CAACpC,IAAI,IACzC1B,OAAO,CAAC0B,IAAI,CAAC,KAAK1B,OAAO,CAAC6G,cAAc,CAAC5E,SAAS,CACpD,CAAC;gBACD;cACF,KAAK,QAAQ;gBACXoB,cAAc,GAAGA,cAAc,CAACS,MAAM,CAACpC,IAAI,IACzC1B,OAAO,CAAC0B,IAAI,CAAC,KAAK1B,OAAO,CAAC6G,cAAc,CAAC5E,SAAS,CAAC,IACnDP,IAAI,CAACqC,QAAQ,CAAC,CAAC,KAAK8C,cAAc,CAAC5E,SAAS,CAAC8B,QAAQ,CAAC,CACxD,CAAC;gBACD;YACJ;YACA;QACJ;;QAEA;QACA,MAAMd,UAA4B,GAAGI,cAAc,CAAC7B,GAAG,CAACE,IAAI,KAAK;UAC/DT,EAAE,EAAE1B,MAAM,CAAC,CAAC;UACZmC,IAAI,EAAE,IAAInB,IAAI,CAACmB,IAAI,CAAC;UACpB2C,MAAM,EAAEwC,cAAc,CAACxC,MAAM;UAC7BF,WAAW,EAAE,eAAe0C,cAAc,CAAC1C,WAAW,EAAE;UACxDG,IAAI,EAAEuC,cAAc,CAACvC;QACvB,CAAC,CAAC,CAAC;QAEH,IAAIrB,UAAU,CAACtB,MAAM,GAAG,CAAC,EAAE;UACzBd,UAAU,CAAC0D,WAAW,IAAI,CAAC,GAAGA,WAAW,EAAE,GAAGtB,UAAU,CAAC,CAAC;QAC5D;MACF;IACF;EACF,CAAC;;EAED;EACA,MAAMiE,sBAAsB,GAAIjG,EAAU,IAAK;IAC7C;IACA,MAAMkG,eAAe,GAAGrG,iBAAiB,CAACiG,IAAI,CAAC/E,OAAO,IAAIA,OAAO,CAACf,EAAE,KAAKA,EAAE,CAAC;IAE5E,IAAIkG,eAAe,EAAE;MACnB;MACAtG,UAAU,CAAC0D,WAAW,IACpBA,WAAW,CAACT,MAAM,CAACrC,KAAK,IACtB,CAACA,KAAK,CAAC0C,WAAW,CAAC8C,UAAU,CAAC,eAAeE,eAAe,CAAChD,WAAW,EAAE,CAC5E,CACF,CAAC;IACH;;IAEA;IACApD,oBAAoB,CAAC4F,YAAY,IAC/BA,YAAY,CAAC7C,MAAM,CAAC9B,OAAO,IAAIA,OAAO,CAACf,EAAE,KAAKA,EAAE,CAClD,CAAC;EACH,CAAC;EAED,OAAO;IACLL,OAAO;IACPwF,QAAQ;IACRE,WAAW;IACXE,WAAW;IACX1F,iBAAiB;IACjB2F,mBAAmB;IACnBG,sBAAsB;IACtBM,sBAAsB;IACtB1C,SAAS;IACTgB;EACF,CAAC;AACH,CAAC;AAAC9E,EAAA,CApkBWF,gBAAgB;EAAA,QACHP,OAAO;AAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}