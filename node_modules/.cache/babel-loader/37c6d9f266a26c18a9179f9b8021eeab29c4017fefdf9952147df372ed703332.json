{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useMemo } from 'react';\nimport { v4 as uuidv4 } from 'uuid';\nimport { format, startOfMonth, endOfMonth, eachDayOfInterval, isAfter, isBefore, isSameDay, isWeekend, getDate } from 'date-fns';\nimport { useAuth } from '../context/AuthContext';\nconst ENTRIES_STORAGE_KEY = 'personal-budget-tracker-entries';\nconst RECURRING_PAYMENTS_STORAGE_KEY = 'personal-budget-tracker-recurring-payments';\n\n// Helper function to safely handle date serialization\nconst dateReviver = (key, value) => {\n  if (key === 'date' || key === 'startDate' || key === 'endDate') {\n    return new Date(value);\n  }\n  return value;\n};\nexport const useFinancialData = (currentDate = new Date()) => {\n  _s();\n  const {\n    currentUser\n  } = useAuth();\n  const [entries, setEntries] = useState([]);\n  const [recurringPayments, setRecurringPayments] = useState([]);\n\n  // Get storage key for the current user\n  const getStorageKey = key => {\n    return currentUser ? `${key}-${currentUser.id}` : key;\n  };\n\n  // Load entries from localStorage\n  useEffect(() => {\n    const savedEntries = localStorage.getItem(getStorageKey(ENTRIES_STORAGE_KEY));\n    if (savedEntries) {\n      const parsedEntries = JSON.parse(savedEntries, dateReviver);\n      setEntries(parsedEntries.map(entry => ({\n        ...entry,\n        date: new Date(entry.date)\n      })));\n    }\n  }, [getStorageKey]);\n\n  // Save entries to localStorage\n  useEffect(() => {\n    if (entries.length > 0) {\n      localStorage.setItem(getStorageKey(ENTRIES_STORAGE_KEY), JSON.stringify(entries));\n    }\n  }, [entries, getStorageKey]);\n\n  // Load recurring payments from localStorage\n  useEffect(() => {\n    const savedRecurringPayments = localStorage.getItem(getStorageKey(RECURRING_PAYMENTS_STORAGE_KEY));\n    if (savedRecurringPayments) {\n      const parsedPayments = JSON.parse(savedRecurringPayments, dateReviver);\n      setRecurringPayments(parsedPayments.map(payment => ({\n        ...payment,\n        startDate: new Date(payment.startDate),\n        endDate: payment.endDate ? new Date(payment.endDate) : undefined,\n        validFrom: new Date(payment.validFrom),\n        validUntil: payment.validUntil ? new Date(payment.validUntil) : undefined\n      })));\n    }\n  }, [getStorageKey]);\n\n  // Save recurring payments to localStorage\n  useEffect(() => {\n    if (recurringPayments.length > 0) {\n      localStorage.setItem(getStorageKey(RECURRING_PAYMENTS_STORAGE_KEY), JSON.stringify(recurringPayments));\n    }\n  }, [recurringPayments, getStorageKey]);\n\n  // Process recurring payments and generate entries\n  useEffect(() => {\n    const processRecurringPayments = () => {\n      // Get current date without time\n      const today = new Date();\n      today.setHours(0, 0, 0, 0);\n\n      // Consider a period of up to 30 days in the past for processing\n      const startDate = new Date(today);\n      startDate.setDate(startDate.getDate() - 30);\n\n      // Prepare new entries generated from recurring payments\n      const newEntries = [];\n\n      // Loop through all recurring payments\n      recurringPayments.forEach(payment => {\n        if (!payment.isActive) return;\n\n        // Check if the payment is currently valid\n        const isValid = isWithinDateRange(today, payment.validFrom, payment.validUntil || new Date(9999, 11, 31) // If no end date, use far future\n        );\n        if (!isValid) return;\n\n        // Get dates to process based on schedule type\n        let datesToProcess = [];\n\n        // Define start date for processing (max of payment's start date or our processing window start)\n        const processingStart = new Date(Math.max(payment.startDate.getTime(), startDate.getTime()));\n\n        // Define end date for processing (min of payment's end date or today)\n        const processingEnd = payment.endDate && isBefore(payment.endDate, today) ? payment.endDate : today;\n\n        // Don't process if the processing period is invalid\n        if (isAfter(processingStart, processingEnd)) return;\n\n        // Get candidate dates based on schedule type\n        switch (payment.scheduleType) {\n          case 'specific-date':\n            // For monthly payments on a specific day of month\n            if (payment.frequency === 'monthly' && payment.dayOfMonth) {\n              // If today's day matches the payment day, and we haven't created this entry before\n              if (getDate(today) === payment.dayOfMonth) {\n                datesToProcess.push(new Date(today));\n              }\n            }\n            // For yearly payments on a specific day of a specific month\n            else if (payment.frequency === 'yearly' && payment.dayOfMonth) {\n              const paymentDate = new Date(today.getFullYear(), payment.startDate.getMonth(), payment.dayOfMonth);\n\n              // If today's date matches the yearly payment date\n              if (isSameDay(today, paymentDate)) {\n                datesToProcess.push(new Date(today));\n              }\n            }\n            break;\n          case 'weekdays-only':\n            // Get all weekdays within the processing window\n            datesToProcess = eachDayOfInterval({\n              start: processingStart,\n              end: processingEnd\n            }).filter(date => !isWeekend(date));\n            break;\n          case 'weekends-only':\n            // Get all weekend days within the processing window\n            datesToProcess = eachDayOfInterval({\n              start: processingStart,\n              end: processingEnd\n            }).filter(date => isWeekend(date));\n            break;\n          case 'custom-range':\n            // Get all dates within the custom range\n            datesToProcess = eachDayOfInterval({\n              start: processingStart,\n              end: processingEnd\n            });\n\n            // Apply frequency filtering\n            switch (payment.frequency) {\n              case 'daily':\n                // All days are included, so no additional filtering\n                break;\n              case 'weekly':\n                // Keep only days whose day of week matches the original start date\n                datesToProcess = datesToProcess.filter(date => date.getDay() === payment.startDate.getDay());\n                break;\n              case 'monthly':\n                // Keep only days whose day of month matches the original start date\n                datesToProcess = datesToProcess.filter(date => getDate(date) === getDate(payment.startDate));\n                break;\n              case 'yearly':\n                // Keep only days whose day and month match the original start date\n                datesToProcess = datesToProcess.filter(date => getDate(date) === getDate(payment.startDate) && date.getMonth() === payment.startDate.getMonth());\n                break;\n            }\n            break;\n        }\n\n        // Create entries for each date to process\n        datesToProcess.forEach(date => {\n          // Check if an entry for this recurring payment already exists on this date\n          const entryExists = entries.some(entry => isSameDay(entry.date, date) && entry.description === `[Recurring] ${payment.description}`);\n          if (!entryExists) {\n            // Create a new entry for this recurring payment\n            newEntries.push({\n              id: uuidv4(),\n              date: new Date(date),\n              amount: payment.amount,\n              description: `[Recurring] ${payment.description}`,\n              type: payment.type\n            });\n          }\n        });\n      });\n\n      // Add new entries if any were generated\n      if (newEntries.length > 0) {\n        setEntries(prevEntries => [...prevEntries, ...newEntries]);\n      }\n    };\n\n    // Process recurring payments\n    if (recurringPayments.length > 0) {\n      processRecurringPayments();\n    }\n  }, [recurringPayments, entries]);\n\n  // Helper function to check if a date is within a date range\n  const isWithinDateRange = (date, start, end) => {\n    return (isSameDay(date, start) || isAfter(date, start)) && (isSameDay(date, end) || isBefore(date, end));\n  };\n\n  // Calculate month data\n  const monthData = useMemo(() => {\n    const startDate = startOfMonth(currentDate);\n    const endDate = endOfMonth(currentDate);\n    const daysInMonth = eachDayOfInterval({\n      start: startDate,\n      end: endDate\n    });\n    const days = daysInMonth.reduce((acc, day) => {\n      const formattedDate = format(day, 'yyyy-MM-dd');\n      const dayEntries = entries.filter(entry => isSameDay(entry.date, day));\n      const totalIncome = dayEntries.filter(entry => entry.type === 'income').reduce((sum, entry) => sum + entry.amount, 0);\n      const totalExpenses = dayEntries.filter(entry => entry.type === 'expense').reduce((sum, entry) => sum + entry.amount, 0);\n      acc[formattedDate] = {\n        date: day,\n        entries: dayEntries,\n        totalIncome,\n        totalExpenses,\n        dailyBalance: totalIncome - totalExpenses,\n        runningBalance: 0 // Calculated after all days are processed\n      };\n      return acc;\n    }, {});\n\n    // Calculate running balance\n    let runningBalance = 0;\n    for (const day of daysInMonth) {\n      const formattedDate = format(day, 'yyyy-MM-dd');\n      runningBalance += days[formattedDate].dailyBalance;\n      days[formattedDate].runningBalance = runningBalance;\n    }\n\n    // Calculate total income, expenses, and balance for the month\n    const totalIncome = Object.values(days).reduce((sum, day) => sum + day.totalIncome, 0);\n    const totalExpenses = Object.values(days).reduce((sum, day) => sum + day.totalExpenses, 0);\n    return {\n      days,\n      totalIncome,\n      totalExpenses,\n      monthlyBalance: totalIncome - totalExpenses\n    };\n  }, [currentDate, entries]);\n\n  // Calculate year data\n  const yearData = useMemo(() => {\n    const year = currentDate.getFullYear();\n    const months = Array.from({\n      length: 12\n    }, (_, i) => i);\n    const monthSummaries = months.map(month => {\n      const monthEntries = entries.filter(entry => entry.date.getFullYear() === year && entry.date.getMonth() === month);\n      const totalIncome = monthEntries.filter(entry => entry.type === 'income').reduce((sum, entry) => sum + entry.amount, 0);\n      const totalExpenses = monthEntries.filter(entry => entry.type === 'expense').reduce((sum, entry) => sum + entry.amount, 0);\n      return {\n        month,\n        year,\n        totalIncome,\n        totalExpenses,\n        monthlyBalance: totalIncome - totalExpenses\n      };\n    });\n    const totalIncome = monthSummaries.reduce((sum, month) => sum + month.totalIncome, 0);\n    const totalExpenses = monthSummaries.reduce((sum, month) => sum + month.totalExpenses, 0);\n    return {\n      year,\n      months: monthSummaries,\n      totalIncome,\n      totalExpenses,\n      yearlyBalance: totalIncome - totalExpenses\n    };\n  }, [currentDate, entries]);\n\n  // Add a new financial entry\n  const addEntry = entry => {\n    const newEntry = {\n      ...entry,\n      id: uuidv4()\n    };\n    setEntries(prevEntries => [...prevEntries, newEntry]);\n  };\n\n  // Update an existing financial entry\n  const updateEntry = updatedEntry => {\n    setEntries(prevEntries => prevEntries.map(entry => entry.id === updatedEntry.id ? updatedEntry : entry));\n  };\n\n  // Delete a financial entry\n  const deleteEntry = id => {\n    setEntries(prevEntries => prevEntries.filter(entry => entry.id !== id));\n  };\n\n  // Add a new recurring payment\n  const addRecurringPayment = payment => {\n    const newPayment = {\n      ...payment,\n      id: uuidv4()\n    };\n    setRecurringPayments(prevPayments => [...prevPayments, newPayment]);\n  };\n\n  // Update an existing recurring payment\n  const updateRecurringPayment = updatedPayment => {\n    setRecurringPayments(prevPayments => prevPayments.map(payment => payment.id === updatedPayment.id ? updatedPayment : payment));\n  };\n\n  // Delete a recurring payment\n  const deleteRecurringPayment = id => {\n    setRecurringPayments(prevPayments => prevPayments.filter(payment => payment.id !== id));\n  };\n  return {\n    entries,\n    addEntry,\n    updateEntry,\n    deleteEntry,\n    recurringPayments,\n    addRecurringPayment,\n    updateRecurringPayment,\n    deleteRecurringPayment,\n    monthData,\n    yearData\n  };\n};\n_s(useFinancialData, \"aPhJgDWCrnE9bmisuKvc8OPXkzg=\", false, function () {\n  return [useAuth];\n});","map":{"version":3,"names":["useState","useEffect","useMemo","v4","uuidv4","format","startOfMonth","endOfMonth","eachDayOfInterval","isAfter","isBefore","isSameDay","isWeekend","getDate","useAuth","ENTRIES_STORAGE_KEY","RECURRING_PAYMENTS_STORAGE_KEY","dateReviver","key","value","Date","useFinancialData","currentDate","_s","currentUser","entries","setEntries","recurringPayments","setRecurringPayments","getStorageKey","id","savedEntries","localStorage","getItem","parsedEntries","JSON","parse","map","entry","date","length","setItem","stringify","savedRecurringPayments","parsedPayments","payment","startDate","endDate","undefined","validFrom","validUntil","processRecurringPayments","today","setHours","setDate","newEntries","forEach","isActive","isValid","isWithinDateRange","datesToProcess","processingStart","Math","max","getTime","processingEnd","scheduleType","frequency","dayOfMonth","push","paymentDate","getFullYear","getMonth","start","end","filter","getDay","entryExists","some","description","amount","type","prevEntries","monthData","daysInMonth","days","reduce","acc","day","formattedDate","dayEntries","totalIncome","sum","totalExpenses","dailyBalance","runningBalance","Object","values","monthlyBalance","yearData","year","months","Array","from","_","i","monthSummaries","month","monthEntries","yearlyBalance","addEntry","newEntry","updateEntry","updatedEntry","deleteEntry","addRecurringPayment","newPayment","prevPayments","updateRecurringPayment","updatedPayment","deleteRecurringPayment"],"sources":["C:/Users/Administrator/Downloads/personal-budget-tracker/src/hooks/useFinancialData.ts"],"sourcesContent":["import { useState, useEffect, useMemo } from 'react';\nimport { \n  FinancialEntry, \n  MonthData, \n  YearData, \n  RecurringPayment, \n  RecurringScheduleType \n} from '../types';\nimport { v4 as uuidv4 } from 'uuid';\nimport { \n  format, \n  startOfMonth, \n  endOfMonth, \n  eachDayOfInterval, \n  isAfter, \n  isBefore, \n  isSameDay, \n  isWithinInterval,\n  addDays,\n  isSameMonth,\n  isSameYear,\n  isWeekend,\n  getDate\n} from 'date-fns';\nimport { useAuth } from '../context/AuthContext';\n\nconst ENTRIES_STORAGE_KEY = 'personal-budget-tracker-entries';\nconst RECURRING_PAYMENTS_STORAGE_KEY = 'personal-budget-tracker-recurring-payments';\n\n// Helper function to safely handle date serialization\nconst dateReviver = (key: string, value: any) => {\n  if (key === 'date' || key === 'startDate' || key === 'endDate') {\n    return new Date(value);\n  }\n  return value;\n};\n\nexport const useFinancialData = (currentDate: Date = new Date()) => {\n  const { currentUser } = useAuth();\n  const [entries, setEntries] = useState<FinancialEntry[]>([]);\n  const [recurringPayments, setRecurringPayments] = useState<RecurringPayment[]>([]);\n\n  // Get storage key for the current user\n  const getStorageKey = (key: string) => {\n    return currentUser \n      ? `${key}-${currentUser.id}`\n      : key;\n  };\n\n  // Load entries from localStorage\n  useEffect(() => {\n    const savedEntries = localStorage.getItem(getStorageKey(ENTRIES_STORAGE_KEY));\n    if (savedEntries) {\n      const parsedEntries = JSON.parse(savedEntries, dateReviver);\n      setEntries(parsedEntries.map((entry: any) => ({\n        ...entry,\n        date: new Date(entry.date)\n      })));\n    }\n  }, [getStorageKey]);\n\n  // Save entries to localStorage\n  useEffect(() => {\n    if (entries.length > 0) {\n      localStorage.setItem(getStorageKey(ENTRIES_STORAGE_KEY), JSON.stringify(entries));\n    }\n  }, [entries, getStorageKey]);\n\n  // Load recurring payments from localStorage\n  useEffect(() => {\n    const savedRecurringPayments = localStorage.getItem(getStorageKey(RECURRING_PAYMENTS_STORAGE_KEY));\n    if (savedRecurringPayments) {\n      const parsedPayments = JSON.parse(savedRecurringPayments, dateReviver);\n      setRecurringPayments(parsedPayments.map((payment: any) => ({\n        ...payment,\n        startDate: new Date(payment.startDate),\n        endDate: payment.endDate ? new Date(payment.endDate) : undefined,\n        validFrom: new Date(payment.validFrom),\n        validUntil: payment.validUntil ? new Date(payment.validUntil) : undefined\n      })));\n    }\n  }, [getStorageKey]);\n\n  // Save recurring payments to localStorage\n  useEffect(() => {\n    if (recurringPayments.length > 0) {\n      localStorage.setItem(getStorageKey(RECURRING_PAYMENTS_STORAGE_KEY), JSON.stringify(recurringPayments));\n    }\n  }, [recurringPayments, getStorageKey]);\n\n  // Process recurring payments and generate entries\n  useEffect(() => {\n    const processRecurringPayments = () => {\n      // Get current date without time\n      const today = new Date();\n      today.setHours(0, 0, 0, 0);\n      \n      // Consider a period of up to 30 days in the past for processing\n      const startDate = new Date(today);\n      startDate.setDate(startDate.getDate() - 30);\n      \n      // Prepare new entries generated from recurring payments\n      const newEntries: FinancialEntry[] = [];\n\n      // Loop through all recurring payments\n      recurringPayments.forEach(payment => {\n        if (!payment.isActive) return;\n\n        // Check if the payment is currently valid\n        const isValid = isWithinDateRange(\n          today, \n          payment.validFrom, \n          payment.validUntil || new Date(9999, 11, 31) // If no end date, use far future\n        );\n\n        if (!isValid) return;\n\n        // Get dates to process based on schedule type\n        let datesToProcess: Date[] = [];\n        \n        // Define start date for processing (max of payment's start date or our processing window start)\n        const processingStart = new Date(Math.max(payment.startDate.getTime(), startDate.getTime()));\n        \n        // Define end date for processing (min of payment's end date or today)\n        const processingEnd = payment.endDate && isBefore(payment.endDate, today) \n          ? payment.endDate \n          : today;\n\n        // Don't process if the processing period is invalid\n        if (isAfter(processingStart, processingEnd)) return;\n\n        // Get candidate dates based on schedule type\n        switch (payment.scheduleType) {\n          case 'specific-date':\n            // For monthly payments on a specific day of month\n            if (payment.frequency === 'monthly' && payment.dayOfMonth) {\n              // If today's day matches the payment day, and we haven't created this entry before\n              if (getDate(today) === payment.dayOfMonth) {\n                datesToProcess.push(new Date(today));\n              }\n            } \n            // For yearly payments on a specific day of a specific month\n            else if (payment.frequency === 'yearly' && payment.dayOfMonth) {\n              const paymentDate = new Date(\n                today.getFullYear(),\n                payment.startDate.getMonth(),\n                payment.dayOfMonth\n              );\n              \n              // If today's date matches the yearly payment date\n              if (isSameDay(today, paymentDate)) {\n                datesToProcess.push(new Date(today));\n              }\n            }\n            break;\n            \n          case 'weekdays-only':\n            // Get all weekdays within the processing window\n            datesToProcess = eachDayOfInterval({ start: processingStart, end: processingEnd })\n              .filter(date => !isWeekend(date));\n            break;\n            \n          case 'weekends-only':\n            // Get all weekend days within the processing window\n            datesToProcess = eachDayOfInterval({ start: processingStart, end: processingEnd })\n              .filter(date => isWeekend(date));\n            break;\n            \n          case 'custom-range':\n            // Get all dates within the custom range\n            datesToProcess = eachDayOfInterval({ start: processingStart, end: processingEnd });\n            \n            // Apply frequency filtering\n            switch (payment.frequency) {\n              case 'daily':\n                // All days are included, so no additional filtering\n                break;\n                \n              case 'weekly':\n                // Keep only days whose day of week matches the original start date\n                datesToProcess = datesToProcess.filter(date => \n                  date.getDay() === payment.startDate.getDay()\n                );\n                break;\n                \n              case 'monthly':\n                // Keep only days whose day of month matches the original start date\n                datesToProcess = datesToProcess.filter(date => \n                  getDate(date) === getDate(payment.startDate)\n                );\n                break;\n                \n              case 'yearly':\n                // Keep only days whose day and month match the original start date\n                datesToProcess = datesToProcess.filter(date => \n                  getDate(date) === getDate(payment.startDate) && \n                  date.getMonth() === payment.startDate.getMonth()\n                );\n                break;\n            }\n            break;\n        }\n\n        // Create entries for each date to process\n        datesToProcess.forEach(date => {\n          // Check if an entry for this recurring payment already exists on this date\n          const entryExists = entries.some(entry => \n            isSameDay(entry.date, date) && \n            entry.description === `[Recurring] ${payment.description}`\n          );\n\n          if (!entryExists) {\n            // Create a new entry for this recurring payment\n            newEntries.push({\n              id: uuidv4(),\n              date: new Date(date),\n              amount: payment.amount,\n              description: `[Recurring] ${payment.description}`,\n              type: payment.type\n            });\n          }\n        });\n      });\n\n      // Add new entries if any were generated\n      if (newEntries.length > 0) {\n        setEntries(prevEntries => [...prevEntries, ...newEntries]);\n      }\n    };\n\n    // Process recurring payments\n    if (recurringPayments.length > 0) {\n      processRecurringPayments();\n    }\n  }, [recurringPayments, entries]);\n\n  // Helper function to check if a date is within a date range\n  const isWithinDateRange = (date: Date, start: Date, end: Date): boolean => {\n    return (\n      (isSameDay(date, start) || isAfter(date, start)) &&\n      (isSameDay(date, end) || isBefore(date, end))\n    );\n  };\n\n  // Calculate month data\n  const monthData = useMemo(() => {\n    const startDate = startOfMonth(currentDate);\n    const endDate = endOfMonth(currentDate);\n    const daysInMonth = eachDayOfInterval({ start: startDate, end: endDate });\n\n    const days = daysInMonth.reduce((acc, day) => {\n      const formattedDate = format(day, 'yyyy-MM-dd');\n      const dayEntries = entries.filter(entry => isSameDay(entry.date, day));\n      \n      const totalIncome = dayEntries\n        .filter(entry => entry.type === 'income')\n        .reduce((sum, entry) => sum + entry.amount, 0);\n      \n      const totalExpenses = dayEntries\n        .filter(entry => entry.type === 'expense')\n        .reduce((sum, entry) => sum + entry.amount, 0);\n\n      acc[formattedDate] = {\n        date: day,\n        entries: dayEntries,\n        totalIncome,\n        totalExpenses,\n        dailyBalance: totalIncome - totalExpenses,\n        runningBalance: 0, // Calculated after all days are processed\n      };\n\n      return acc;\n    }, {} as Record<string, any>);\n\n    // Calculate running balance\n    let runningBalance = 0;\n    for (const day of daysInMonth) {\n      const formattedDate = format(day, 'yyyy-MM-dd');\n      runningBalance += days[formattedDate].dailyBalance;\n      days[formattedDate].runningBalance = runningBalance;\n    }\n\n    // Calculate total income, expenses, and balance for the month\n    const totalIncome = Object.values(days).reduce(\n      (sum, day: any) => sum + day.totalIncome,\n      0\n    );\n    const totalExpenses = Object.values(days).reduce(\n      (sum, day: any) => sum + day.totalExpenses,\n      0\n    );\n\n    return {\n      days,\n      totalIncome,\n      totalExpenses,\n      monthlyBalance: totalIncome - totalExpenses,\n    };\n  }, [currentDate, entries]);\n\n  // Calculate year data\n  const yearData = useMemo(() => {\n    const year = currentDate.getFullYear();\n    const months = Array.from({ length: 12 }, (_, i) => i);\n\n    const monthSummaries = months.map(month => {\n      const monthEntries = entries.filter(entry => \n        entry.date.getFullYear() === year && \n        entry.date.getMonth() === month\n      );\n\n      const totalIncome = monthEntries\n        .filter(entry => entry.type === 'income')\n        .reduce((sum, entry) => sum + entry.amount, 0);\n      \n      const totalExpenses = monthEntries\n        .filter(entry => entry.type === 'expense')\n        .reduce((sum, entry) => sum + entry.amount, 0);\n\n      return {\n        month,\n        year,\n        totalIncome,\n        totalExpenses,\n        monthlyBalance: totalIncome - totalExpenses,\n      };\n    });\n\n    const totalIncome = monthSummaries.reduce(\n      (sum, month) => sum + month.totalIncome,\n      0\n    );\n    const totalExpenses = monthSummaries.reduce(\n      (sum, month) => sum + month.totalExpenses,\n      0\n    );\n\n    return {\n      year,\n      months: monthSummaries,\n      totalIncome,\n      totalExpenses,\n      yearlyBalance: totalIncome - totalExpenses,\n    };\n  }, [currentDate, entries]);\n\n  // Add a new financial entry\n  const addEntry = (entry: Omit<FinancialEntry, 'id'>) => {\n    const newEntry = {\n      ...entry,\n      id: uuidv4(),\n    };\n    setEntries(prevEntries => [...prevEntries, newEntry]);\n  };\n\n  // Update an existing financial entry\n  const updateEntry = (updatedEntry: FinancialEntry) => {\n    setEntries(prevEntries =>\n      prevEntries.map(entry => \n        entry.id === updatedEntry.id ? updatedEntry : entry\n      )\n    );\n  };\n\n  // Delete a financial entry\n  const deleteEntry = (id: string) => {\n    setEntries(prevEntries => prevEntries.filter(entry => entry.id !== id));\n  };\n\n  // Add a new recurring payment\n  const addRecurringPayment = (payment: Omit<RecurringPayment, 'id'>) => {\n    const newPayment = {\n      ...payment,\n      id: uuidv4(),\n    };\n    setRecurringPayments(prevPayments => [...prevPayments, newPayment]);\n  };\n\n  // Update an existing recurring payment\n  const updateRecurringPayment = (updatedPayment: RecurringPayment) => {\n    setRecurringPayments(prevPayments =>\n      prevPayments.map(payment =>\n        payment.id === updatedPayment.id ? updatedPayment : payment\n      )\n    );\n  };\n\n  // Delete a recurring payment\n  const deleteRecurringPayment = (id: string) => {\n    setRecurringPayments(prevPayments => \n      prevPayments.filter(payment => payment.id !== id)\n    );\n  };\n\n  return {\n    entries,\n    addEntry,\n    updateEntry,\n    deleteEntry,\n    recurringPayments,\n    addRecurringPayment,\n    updateRecurringPayment,\n    deleteRecurringPayment,\n    monthData,\n    yearData,\n  };\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}