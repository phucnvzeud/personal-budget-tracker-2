{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useMemo } from 'react';\nimport { v4 as uuidv4 } from 'uuid';\nimport { format, startOfMonth, endOfMonth, eachDayOfInterval, isAfter, isBefore, isSameDay, isWeekend, getDate } from 'date-fns';\nimport { useAuth } from '../context/AuthContext';\nconst ENTRIES_STORAGE_KEY = 'personal-budget-tracker-entries';\nconst RECURRING_PAYMENTS_STORAGE_KEY = 'personal-budget-tracker-recurring-payments';\n\n// Helper function to safely handle date serialization\nconst dateReviver = (key, value) => {\n  if (key === 'date' || key === 'startDate' || key === 'endDate') {\n    return new Date(value);\n  }\n  return value;\n};\nexport const useFinancialData = (currentDate = new Date()) => {\n  _s();\n  const {\n    currentUser\n  } = useAuth();\n  const [entries, setEntries] = useState([]);\n  const [recurringPayments, setRecurringPayments] = useState([]);\n\n  // Get storage key for the current user\n  const getStorageKey = key => {\n    return currentUser ? `${key}-${currentUser.id}` : key;\n  };\n\n  // Load entries from localStorage\n  useEffect(() => {\n    const savedEntries = localStorage.getItem(getStorageKey(ENTRIES_STORAGE_KEY));\n    if (savedEntries) {\n      const parsedEntries = JSON.parse(savedEntries, dateReviver);\n      setEntries(parsedEntries.map(entry => ({\n        ...entry,\n        date: new Date(entry.date)\n      })));\n    }\n  }, [getStorageKey]);\n\n  // Save entries to localStorage\n  useEffect(() => {\n    if (entries.length > 0) {\n      localStorage.setItem(getStorageKey(ENTRIES_STORAGE_KEY), JSON.stringify(entries));\n    }\n  }, [entries, getStorageKey]);\n\n  // Load recurring payments from localStorage\n  useEffect(() => {\n    const savedRecurringPayments = localStorage.getItem(getStorageKey(RECURRING_PAYMENTS_STORAGE_KEY));\n    if (savedRecurringPayments) {\n      const parsedPayments = JSON.parse(savedRecurringPayments, dateReviver);\n      setRecurringPayments(parsedPayments.map(payment => ({\n        ...payment,\n        startDate: new Date(payment.startDate),\n        endDate: payment.endDate ? new Date(payment.endDate) : undefined,\n        validFrom: new Date(payment.validFrom),\n        validUntil: payment.validUntil ? new Date(payment.validUntil) : undefined\n      })));\n    }\n  }, [getStorageKey]);\n\n  // Save recurring payments to localStorage\n  useEffect(() => {\n    if (recurringPayments.length > 0) {\n      localStorage.setItem(getStorageKey(RECURRING_PAYMENTS_STORAGE_KEY), JSON.stringify(recurringPayments));\n    }\n  }, [recurringPayments, getStorageKey]);\n\n  // Process recurring payments and generate entries\n  useEffect(() => {\n    const processRecurringPayments = () => {\n      // Get current date without time\n      const today = new Date();\n      today.setHours(0, 0, 0, 0);\n\n      // Consider a period of up to 30 days in the past for processing\n      const startDate = new Date(today);\n      startDate.setDate(startDate.getDate() - 30);\n\n      // Also include future entries for the current month\n      const endOfCurrentMonth = endOfMonth(today);\n\n      // Prepare new entries generated from recurring payments\n      const newEntries = [];\n\n      // Loop through all recurring payments\n      recurringPayments.forEach(payment => {\n        if (!payment.isActive) return;\n\n        // Check if the payment is currently valid\n        const isValid = isWithinDateRange(today, payment.validFrom, payment.validUntil || new Date(9999, 11, 31) // If no end date, use far future\n        );\n        if (!isValid) return;\n\n        // Get dates to process based on schedule type\n        let datesToProcess = [];\n\n        // Define start date for processing (max of payment's start date or our processing window start)\n        const processingStart = new Date(Math.max(payment.startDate.getTime(), startDate.getTime()));\n\n        // Define end date for processing (min of payment's end date or end of current month)\n        const processingEnd = payment.endDate && isBefore(payment.endDate, endOfCurrentMonth) ? payment.endDate : endOfCurrentMonth;\n\n        // Don't process if the processing period is invalid\n        if (isAfter(processingStart, processingEnd)) return;\n\n        // Get candidate dates based on schedule type\n        switch (payment.scheduleType) {\n          case 'specific-date':\n            // For monthly payments on a specific day of month\n            if (payment.frequency === 'monthly' && payment.dayOfMonth) {\n              // Get all days in the processing range\n              const allDays = eachDayOfInterval({\n                start: processingStart,\n                end: processingEnd\n              });\n              // Filter for days that match the day of month\n              datesToProcess = allDays.filter(date => getDate(date) === payment.dayOfMonth);\n            }\n            // For yearly payments on a specific day of a specific month\n            else if (payment.frequency === 'yearly' && payment.dayOfMonth) {\n              // Get all days in the processing range\n              const allDays = eachDayOfInterval({\n                start: processingStart,\n                end: processingEnd\n              });\n              // Filter for days that match both the month and day\n              datesToProcess = allDays.filter(date => getDate(date) === payment.dayOfMonth && date.getMonth() === payment.startDate.getMonth());\n            }\n            break;\n          case 'weekdays-only':\n            // Get all weekdays within the processing window\n            datesToProcess = eachDayOfInterval({\n              start: processingStart,\n              end: processingEnd\n            }).filter(date => !isWeekend(date));\n            break;\n          case 'weekends-only':\n            // Get all weekend days within the processing window\n            datesToProcess = eachDayOfInterval({\n              start: processingStart,\n              end: processingEnd\n            }).filter(date => isWeekend(date));\n            break;\n          case 'custom-range':\n            // Get all dates within the custom range\n            datesToProcess = eachDayOfInterval({\n              start: processingStart,\n              end: processingEnd\n            });\n\n            // Apply frequency filtering\n            switch (payment.frequency) {\n              case 'daily':\n                // All days are included, so no additional filtering\n                break;\n              case 'weekly':\n                // Keep only days whose day of week matches the original start date\n                datesToProcess = datesToProcess.filter(date => date.getDay() === payment.startDate.getDay());\n                break;\n              case 'monthly':\n                // Keep only days whose day of month matches the original start date\n                datesToProcess = datesToProcess.filter(date => getDate(date) === getDate(payment.startDate));\n                break;\n              case 'yearly':\n                // Keep only days whose day and month match the original start date\n                datesToProcess = datesToProcess.filter(date => getDate(date) === getDate(payment.startDate) && date.getMonth() === payment.startDate.getMonth());\n                break;\n            }\n            break;\n        }\n\n        // Create entries for each date to process\n        datesToProcess.forEach(date => {\n          // Check if an entry for this recurring payment already exists on this date\n          const entryExists = entries.some(entry => isSameDay(entry.date, date) && entry.description === `[Recurring] ${payment.description}`);\n          if (!entryExists) {\n            // Create a new entry for this recurring payment\n            newEntries.push({\n              id: uuidv4(),\n              date: new Date(date),\n              amount: payment.amount,\n              description: `[Recurring] ${payment.description}`,\n              type: payment.type\n            });\n          }\n        });\n      });\n\n      // Add new entries if any were generated\n      if (newEntries.length > 0) {\n        setEntries(prevEntries => [...prevEntries, ...newEntries]);\n      }\n    };\n\n    // Process recurring payments\n    if (recurringPayments.length > 0) {\n      processRecurringPayments();\n    }\n  }, [recurringPayments, entries]);\n\n  // Helper function to check if a date is within a date range\n  const isWithinDateRange = (date, start, end) => {\n    return (isSameDay(date, start) || isAfter(date, start)) && (isSameDay(date, end) || isBefore(date, end));\n  };\n\n  // Calculate month data\n  const monthData = useMemo(() => {\n    const startDate = startOfMonth(currentDate);\n    const endDate = endOfMonth(currentDate);\n    const daysInMonth = eachDayOfInterval({\n      start: startDate,\n      end: endDate\n    });\n    const days = daysInMonth.reduce((acc, day) => {\n      const formattedDate = format(day, 'yyyy-MM-dd');\n      const dayEntries = entries.filter(entry => isSameDay(entry.date, day));\n      const totalIncome = dayEntries.filter(entry => entry.type === 'income').reduce((sum, entry) => sum + entry.amount, 0);\n      const totalExpenses = dayEntries.filter(entry => entry.type === 'expense').reduce((sum, entry) => sum + entry.amount, 0);\n      acc[formattedDate] = {\n        date: day,\n        entries: dayEntries,\n        totalIncome,\n        totalExpenses,\n        dailyBalance: totalIncome - totalExpenses,\n        runningBalance: 0 // Calculated after all days are processed\n      };\n      return acc;\n    }, {});\n\n    // Calculate running balance\n    let runningBalance = 0;\n    for (const day of daysInMonth) {\n      const formattedDate = format(day, 'yyyy-MM-dd');\n      runningBalance += days[formattedDate].dailyBalance;\n      days[formattedDate].runningBalance = runningBalance;\n    }\n\n    // Calculate total income, expenses, and balance for the month\n    const totalIncome = Object.values(days).reduce((sum, day) => sum + day.totalIncome, 0);\n    const totalExpenses = Object.values(days).reduce((sum, day) => sum + day.totalExpenses, 0);\n    return {\n      days,\n      totalIncome,\n      totalExpenses,\n      monthlyBalance: totalIncome - totalExpenses\n    };\n  }, [currentDate, entries]);\n\n  // Calculate year data\n  const yearData = useMemo(() => {\n    const year = currentDate.getFullYear();\n    const months = Array.from({\n      length: 12\n    }, (_, i) => i);\n    const monthSummaries = months.map(month => {\n      const monthEntries = entries.filter(entry => entry.date.getFullYear() === year && entry.date.getMonth() === month);\n      const totalIncome = monthEntries.filter(entry => entry.type === 'income').reduce((sum, entry) => sum + entry.amount, 0);\n      const totalExpenses = monthEntries.filter(entry => entry.type === 'expense').reduce((sum, entry) => sum + entry.amount, 0);\n      return {\n        month,\n        year,\n        totalIncome,\n        totalExpenses,\n        monthlyBalance: totalIncome - totalExpenses\n      };\n    });\n    const totalIncome = monthSummaries.reduce((sum, month) => sum + month.totalIncome, 0);\n    const totalExpenses = monthSummaries.reduce((sum, month) => sum + month.totalExpenses, 0);\n    return {\n      year,\n      months: monthSummaries,\n      totalIncome,\n      totalExpenses,\n      yearlyBalance: totalIncome - totalExpenses\n    };\n  }, [currentDate, entries]);\n\n  // Add a new financial entry\n  const addEntry = entry => {\n    const newEntry = {\n      ...entry,\n      id: uuidv4()\n    };\n    setEntries(prevEntries => [...prevEntries, newEntry]);\n  };\n\n  // Update an existing financial entry\n  const updateEntry = updatedEntry => {\n    setEntries(prevEntries => prevEntries.map(entry => entry.id === updatedEntry.id ? updatedEntry : entry));\n  };\n\n  // Delete a financial entry\n  const deleteEntry = id => {\n    setEntries(prevEntries => prevEntries.filter(entry => entry.id !== id));\n  };\n\n  // Add a new recurring payment\n  const addRecurringPayment = payment => {\n    const newPayment = {\n      ...payment,\n      id: uuidv4()\n    };\n\n    // Immediately process this new payment to create entries\n    const today = new Date();\n    today.setHours(0, 0, 0, 0);\n    const endOfCurrentMonth = endOfMonth(today);\n    let datesToProcess = [];\n    if (newPayment.isActive) {\n      // Check if the payment schedule is valid for the current month\n      const processingStart = new Date(Math.max(newPayment.startDate.getTime(), today.getTime()));\n      const processingEnd = newPayment.endDate && isBefore(newPayment.endDate, endOfCurrentMonth) ? newPayment.endDate : endOfCurrentMonth;\n      if (!isAfter(processingStart, processingEnd)) {\n        // Get dates based on schedule type\n        switch (newPayment.scheduleType) {\n          case 'specific-date':\n            if (newPayment.frequency === 'monthly' && newPayment.dayOfMonth) {\n              const allDays = eachDayOfInterval({\n                start: processingStart,\n                end: processingEnd\n              });\n              datesToProcess = allDays.filter(date => getDate(date) === newPayment.dayOfMonth);\n            } else if (newPayment.frequency === 'yearly' && newPayment.dayOfMonth) {\n              const allDays = eachDayOfInterval({\n                start: processingStart,\n                end: processingEnd\n              });\n              datesToProcess = allDays.filter(date => getDate(date) === newPayment.dayOfMonth && date.getMonth() === newPayment.startDate.getMonth());\n            }\n            break;\n          case 'weekdays-only':\n            datesToProcess = eachDayOfInterval({\n              start: processingStart,\n              end: processingEnd\n            }).filter(date => !isWeekend(date));\n            break;\n          case 'weekends-only':\n            datesToProcess = eachDayOfInterval({\n              start: processingStart,\n              end: processingEnd\n            }).filter(date => isWeekend(date));\n            break;\n          case 'custom-range':\n            datesToProcess = eachDayOfInterval({\n              start: processingStart,\n              end: processingEnd\n            });\n            switch (newPayment.frequency) {\n              case 'daily':\n                break;\n              case 'weekly':\n                datesToProcess = datesToProcess.filter(date => date.getDay() === newPayment.startDate.getDay());\n                break;\n              case 'monthly':\n                datesToProcess = datesToProcess.filter(date => getDate(date) === getDate(newPayment.startDate));\n                break;\n              case 'yearly':\n                datesToProcess = datesToProcess.filter(date => getDate(date) === getDate(newPayment.startDate) && date.getMonth() === newPayment.startDate.getMonth());\n                break;\n            }\n            break;\n        }\n\n        // Create entries for dates\n        const newEntries = datesToProcess.map(date => ({\n          id: uuidv4(),\n          date: new Date(date),\n          amount: newPayment.amount,\n          description: `[Recurring] ${newPayment.description}`,\n          type: newPayment.type\n        }));\n        if (newEntries.length > 0) {\n          setEntries(prevEntries => [...prevEntries, ...newEntries]);\n        }\n      }\n    }\n    setRecurringPayments(prevPayments => [...prevPayments, newPayment]);\n  };\n\n  // Update an existing recurring payment\n  const updateRecurringPayment = updatedPayment => {\n    setRecurringPayments(prevPayments => prevPayments.map(payment => payment.id === updatedPayment.id ? updatedPayment : payment));\n  };\n\n  // Delete a recurring payment\n  const deleteRecurringPayment = id => {\n    setRecurringPayments(prevPayments => prevPayments.filter(payment => payment.id !== id));\n  };\n  return {\n    entries,\n    addEntry,\n    updateEntry,\n    deleteEntry,\n    recurringPayments,\n    addRecurringPayment,\n    updateRecurringPayment,\n    deleteRecurringPayment,\n    monthData,\n    yearData\n  };\n};\n_s(useFinancialData, \"aPhJgDWCrnE9bmisuKvc8OPXkzg=\", false, function () {\n  return [useAuth];\n});","map":{"version":3,"names":["useState","useEffect","useMemo","v4","uuidv4","format","startOfMonth","endOfMonth","eachDayOfInterval","isAfter","isBefore","isSameDay","isWeekend","getDate","useAuth","ENTRIES_STORAGE_KEY","RECURRING_PAYMENTS_STORAGE_KEY","dateReviver","key","value","Date","useFinancialData","currentDate","_s","currentUser","entries","setEntries","recurringPayments","setRecurringPayments","getStorageKey","id","savedEntries","localStorage","getItem","parsedEntries","JSON","parse","map","entry","date","length","setItem","stringify","savedRecurringPayments","parsedPayments","payment","startDate","endDate","undefined","validFrom","validUntil","processRecurringPayments","today","setHours","setDate","endOfCurrentMonth","newEntries","forEach","isActive","isValid","isWithinDateRange","datesToProcess","processingStart","Math","max","getTime","processingEnd","scheduleType","frequency","dayOfMonth","allDays","start","end","filter","getMonth","getDay","entryExists","some","description","push","amount","type","prevEntries","monthData","daysInMonth","days","reduce","acc","day","formattedDate","dayEntries","totalIncome","sum","totalExpenses","dailyBalance","runningBalance","Object","values","monthlyBalance","yearData","year","getFullYear","months","Array","from","_","i","monthSummaries","month","monthEntries","yearlyBalance","addEntry","newEntry","updateEntry","updatedEntry","deleteEntry","addRecurringPayment","newPayment","prevPayments","updateRecurringPayment","updatedPayment","deleteRecurringPayment"],"sources":["C:/Users/Administrator/Downloads/personal-budget-tracker/src/hooks/useFinancialData.ts"],"sourcesContent":["import { useState, useEffect, useMemo } from 'react';\nimport { \n  FinancialEntry, \n  MonthData, \n  YearData, \n  RecurringPayment, \n  RecurringScheduleType \n} from '../types';\nimport { v4 as uuidv4 } from 'uuid';\nimport { \n  format, \n  startOfMonth, \n  endOfMonth, \n  eachDayOfInterval, \n  isAfter, \n  isBefore, \n  isSameDay, \n  isWithinInterval,\n  addDays,\n  isSameMonth,\n  isSameYear,\n  isWeekend,\n  getDate\n} from 'date-fns';\nimport { useAuth } from '../context/AuthContext';\n\nconst ENTRIES_STORAGE_KEY = 'personal-budget-tracker-entries';\nconst RECURRING_PAYMENTS_STORAGE_KEY = 'personal-budget-tracker-recurring-payments';\n\n// Helper function to safely handle date serialization\nconst dateReviver = (key: string, value: any) => {\n  if (key === 'date' || key === 'startDate' || key === 'endDate') {\n    return new Date(value);\n  }\n  return value;\n};\n\nexport const useFinancialData = (currentDate: Date = new Date()) => {\n  const { currentUser } = useAuth();\n  const [entries, setEntries] = useState<FinancialEntry[]>([]);\n  const [recurringPayments, setRecurringPayments] = useState<RecurringPayment[]>([]);\n\n  // Get storage key for the current user\n  const getStorageKey = (key: string) => {\n    return currentUser \n      ? `${key}-${currentUser.id}`\n      : key;\n  };\n\n  // Load entries from localStorage\n  useEffect(() => {\n    const savedEntries = localStorage.getItem(getStorageKey(ENTRIES_STORAGE_KEY));\n    if (savedEntries) {\n      const parsedEntries = JSON.parse(savedEntries, dateReviver);\n      setEntries(parsedEntries.map((entry: any) => ({\n        ...entry,\n        date: new Date(entry.date)\n      })));\n    }\n  }, [getStorageKey]);\n\n  // Save entries to localStorage\n  useEffect(() => {\n    if (entries.length > 0) {\n      localStorage.setItem(getStorageKey(ENTRIES_STORAGE_KEY), JSON.stringify(entries));\n    }\n  }, [entries, getStorageKey]);\n\n  // Load recurring payments from localStorage\n  useEffect(() => {\n    const savedRecurringPayments = localStorage.getItem(getStorageKey(RECURRING_PAYMENTS_STORAGE_KEY));\n    if (savedRecurringPayments) {\n      const parsedPayments = JSON.parse(savedRecurringPayments, dateReviver);\n      setRecurringPayments(parsedPayments.map((payment: any) => ({\n        ...payment,\n        startDate: new Date(payment.startDate),\n        endDate: payment.endDate ? new Date(payment.endDate) : undefined,\n        validFrom: new Date(payment.validFrom),\n        validUntil: payment.validUntil ? new Date(payment.validUntil) : undefined\n      })));\n    }\n  }, [getStorageKey]);\n\n  // Save recurring payments to localStorage\n  useEffect(() => {\n    if (recurringPayments.length > 0) {\n      localStorage.setItem(getStorageKey(RECURRING_PAYMENTS_STORAGE_KEY), JSON.stringify(recurringPayments));\n    }\n  }, [recurringPayments, getStorageKey]);\n\n  // Process recurring payments and generate entries\n  useEffect(() => {\n    const processRecurringPayments = () => {\n      // Get current date without time\n      const today = new Date();\n      today.setHours(0, 0, 0, 0);\n      \n      // Consider a period of up to 30 days in the past for processing\n      const startDate = new Date(today);\n      startDate.setDate(startDate.getDate() - 30);\n      \n      // Also include future entries for the current month\n      const endOfCurrentMonth = endOfMonth(today);\n      \n      // Prepare new entries generated from recurring payments\n      const newEntries: FinancialEntry[] = [];\n\n      // Loop through all recurring payments\n      recurringPayments.forEach(payment => {\n        if (!payment.isActive) return;\n\n        // Check if the payment is currently valid\n        const isValid = isWithinDateRange(\n          today, \n          payment.validFrom, \n          payment.validUntil || new Date(9999, 11, 31) // If no end date, use far future\n        );\n\n        if (!isValid) return;\n\n        // Get dates to process based on schedule type\n        let datesToProcess: Date[] = [];\n        \n        // Define start date for processing (max of payment's start date or our processing window start)\n        const processingStart = new Date(Math.max(payment.startDate.getTime(), startDate.getTime()));\n        \n        // Define end date for processing (min of payment's end date or end of current month)\n        const processingEnd = payment.endDate && isBefore(payment.endDate, endOfCurrentMonth) \n          ? payment.endDate \n          : endOfCurrentMonth;\n\n        // Don't process if the processing period is invalid\n        if (isAfter(processingStart, processingEnd)) return;\n\n        // Get candidate dates based on schedule type\n        switch (payment.scheduleType) {\n          case 'specific-date':\n            // For monthly payments on a specific day of month\n            if (payment.frequency === 'monthly' && payment.dayOfMonth) {\n              // Get all days in the processing range\n              const allDays = eachDayOfInterval({ start: processingStart, end: processingEnd });\n              // Filter for days that match the day of month\n              datesToProcess = allDays.filter(date => getDate(date) === payment.dayOfMonth);\n            } \n            // For yearly payments on a specific day of a specific month\n            else if (payment.frequency === 'yearly' && payment.dayOfMonth) {\n              // Get all days in the processing range\n              const allDays = eachDayOfInterval({ start: processingStart, end: processingEnd });\n              // Filter for days that match both the month and day\n              datesToProcess = allDays.filter(date => \n                getDate(date) === payment.dayOfMonth &&\n                date.getMonth() === payment.startDate.getMonth()\n              );\n            }\n            break;\n            \n          case 'weekdays-only':\n            // Get all weekdays within the processing window\n            datesToProcess = eachDayOfInterval({ start: processingStart, end: processingEnd })\n              .filter(date => !isWeekend(date));\n            break;\n            \n          case 'weekends-only':\n            // Get all weekend days within the processing window\n            datesToProcess = eachDayOfInterval({ start: processingStart, end: processingEnd })\n              .filter(date => isWeekend(date));\n            break;\n            \n          case 'custom-range':\n            // Get all dates within the custom range\n            datesToProcess = eachDayOfInterval({ start: processingStart, end: processingEnd });\n            \n            // Apply frequency filtering\n            switch (payment.frequency) {\n              case 'daily':\n                // All days are included, so no additional filtering\n                break;\n                \n              case 'weekly':\n                // Keep only days whose day of week matches the original start date\n                datesToProcess = datesToProcess.filter(date => \n                  date.getDay() === payment.startDate.getDay()\n                );\n                break;\n                \n              case 'monthly':\n                // Keep only days whose day of month matches the original start date\n                datesToProcess = datesToProcess.filter(date => \n                  getDate(date) === getDate(payment.startDate)\n                );\n                break;\n                \n              case 'yearly':\n                // Keep only days whose day and month match the original start date\n                datesToProcess = datesToProcess.filter(date => \n                  getDate(date) === getDate(payment.startDate) && \n                  date.getMonth() === payment.startDate.getMonth()\n                );\n                break;\n            }\n            break;\n        }\n\n        // Create entries for each date to process\n        datesToProcess.forEach(date => {\n          // Check if an entry for this recurring payment already exists on this date\n          const entryExists = entries.some(entry => \n            isSameDay(entry.date, date) && \n            entry.description === `[Recurring] ${payment.description}`\n          );\n\n          if (!entryExists) {\n            // Create a new entry for this recurring payment\n            newEntries.push({\n              id: uuidv4(),\n              date: new Date(date),\n              amount: payment.amount,\n              description: `[Recurring] ${payment.description}`,\n              type: payment.type\n            });\n          }\n        });\n      });\n\n      // Add new entries if any were generated\n      if (newEntries.length > 0) {\n        setEntries(prevEntries => [...prevEntries, ...newEntries]);\n      }\n    };\n\n    // Process recurring payments\n    if (recurringPayments.length > 0) {\n      processRecurringPayments();\n    }\n  }, [recurringPayments, entries]);\n\n  // Helper function to check if a date is within a date range\n  const isWithinDateRange = (date: Date, start: Date, end: Date): boolean => {\n    return (\n      (isSameDay(date, start) || isAfter(date, start)) &&\n      (isSameDay(date, end) || isBefore(date, end))\n    );\n  };\n\n  // Calculate month data\n  const monthData = useMemo(() => {\n    const startDate = startOfMonth(currentDate);\n    const endDate = endOfMonth(currentDate);\n    const daysInMonth = eachDayOfInterval({ start: startDate, end: endDate });\n\n    const days = daysInMonth.reduce((acc, day) => {\n      const formattedDate = format(day, 'yyyy-MM-dd');\n      const dayEntries = entries.filter(entry => isSameDay(entry.date, day));\n      \n      const totalIncome = dayEntries\n        .filter(entry => entry.type === 'income')\n        .reduce((sum, entry) => sum + entry.amount, 0);\n      \n      const totalExpenses = dayEntries\n        .filter(entry => entry.type === 'expense')\n        .reduce((sum, entry) => sum + entry.amount, 0);\n\n      acc[formattedDate] = {\n        date: day,\n        entries: dayEntries,\n        totalIncome,\n        totalExpenses,\n        dailyBalance: totalIncome - totalExpenses,\n        runningBalance: 0, // Calculated after all days are processed\n      };\n\n      return acc;\n    }, {} as Record<string, any>);\n\n    // Calculate running balance\n    let runningBalance = 0;\n    for (const day of daysInMonth) {\n      const formattedDate = format(day, 'yyyy-MM-dd');\n      runningBalance += days[formattedDate].dailyBalance;\n      days[formattedDate].runningBalance = runningBalance;\n    }\n\n    // Calculate total income, expenses, and balance for the month\n    const totalIncome = Object.values(days).reduce(\n      (sum, day: any) => sum + day.totalIncome,\n      0\n    );\n    const totalExpenses = Object.values(days).reduce(\n      (sum, day: any) => sum + day.totalExpenses,\n      0\n    );\n\n    return {\n      days,\n      totalIncome,\n      totalExpenses,\n      monthlyBalance: totalIncome - totalExpenses,\n    };\n  }, [currentDate, entries]);\n\n  // Calculate year data\n  const yearData = useMemo(() => {\n    const year = currentDate.getFullYear();\n    const months = Array.from({ length: 12 }, (_, i) => i);\n\n    const monthSummaries = months.map(month => {\n      const monthEntries = entries.filter(entry => \n        entry.date.getFullYear() === year && \n        entry.date.getMonth() === month\n      );\n\n      const totalIncome = monthEntries\n        .filter(entry => entry.type === 'income')\n        .reduce((sum, entry) => sum + entry.amount, 0);\n      \n      const totalExpenses = monthEntries\n        .filter(entry => entry.type === 'expense')\n        .reduce((sum, entry) => sum + entry.amount, 0);\n\n      return {\n        month,\n        year,\n        totalIncome,\n        totalExpenses,\n        monthlyBalance: totalIncome - totalExpenses,\n      };\n    });\n\n    const totalIncome = monthSummaries.reduce(\n      (sum, month) => sum + month.totalIncome,\n      0\n    );\n    const totalExpenses = monthSummaries.reduce(\n      (sum, month) => sum + month.totalExpenses,\n      0\n    );\n\n    return {\n      year,\n      months: monthSummaries,\n      totalIncome,\n      totalExpenses,\n      yearlyBalance: totalIncome - totalExpenses,\n    };\n  }, [currentDate, entries]);\n\n  // Add a new financial entry\n  const addEntry = (entry: Omit<FinancialEntry, 'id'>) => {\n    const newEntry = {\n      ...entry,\n      id: uuidv4(),\n    };\n    setEntries(prevEntries => [...prevEntries, newEntry]);\n  };\n\n  // Update an existing financial entry\n  const updateEntry = (updatedEntry: FinancialEntry) => {\n    setEntries(prevEntries =>\n      prevEntries.map(entry => \n        entry.id === updatedEntry.id ? updatedEntry : entry\n      )\n    );\n  };\n\n  // Delete a financial entry\n  const deleteEntry = (id: string) => {\n    setEntries(prevEntries => prevEntries.filter(entry => entry.id !== id));\n  };\n\n  // Add a new recurring payment\n  const addRecurringPayment = (payment: Omit<RecurringPayment, 'id'>) => {\n    const newPayment = {\n      ...payment,\n      id: uuidv4(),\n    };\n    \n    // Immediately process this new payment to create entries\n    const today = new Date();\n    today.setHours(0, 0, 0, 0);\n    \n    const endOfCurrentMonth = endOfMonth(today);\n    let datesToProcess: Date[] = [];\n    \n    if (newPayment.isActive) {\n      // Check if the payment schedule is valid for the current month\n      const processingStart = new Date(Math.max(newPayment.startDate.getTime(), today.getTime()));\n      const processingEnd = newPayment.endDate && isBefore(newPayment.endDate, endOfCurrentMonth) \n        ? newPayment.endDate \n        : endOfCurrentMonth;\n      \n      if (!isAfter(processingStart, processingEnd)) {\n        // Get dates based on schedule type\n        switch (newPayment.scheduleType) {\n          case 'specific-date':\n            if (newPayment.frequency === 'monthly' && newPayment.dayOfMonth) {\n              const allDays = eachDayOfInterval({ start: processingStart, end: processingEnd });\n              datesToProcess = allDays.filter(date => getDate(date) === newPayment.dayOfMonth);\n            } else if (newPayment.frequency === 'yearly' && newPayment.dayOfMonth) {\n              const allDays = eachDayOfInterval({ start: processingStart, end: processingEnd });\n              datesToProcess = allDays.filter(date => \n                getDate(date) === newPayment.dayOfMonth &&\n                date.getMonth() === newPayment.startDate.getMonth()\n              );\n            }\n            break;\n          case 'weekdays-only':\n            datesToProcess = eachDayOfInterval({ start: processingStart, end: processingEnd })\n              .filter(date => !isWeekend(date));\n            break;\n          case 'weekends-only':\n            datesToProcess = eachDayOfInterval({ start: processingStart, end: processingEnd })\n              .filter(date => isWeekend(date));\n            break;\n          case 'custom-range':\n            datesToProcess = eachDayOfInterval({ start: processingStart, end: processingEnd });\n            \n            switch (newPayment.frequency) {\n              case 'daily':\n                break;\n              case 'weekly':\n                datesToProcess = datesToProcess.filter(date => \n                  date.getDay() === newPayment.startDate.getDay()\n                );\n                break;\n              case 'monthly':\n                datesToProcess = datesToProcess.filter(date => \n                  getDate(date) === getDate(newPayment.startDate)\n                );\n                break;\n              case 'yearly':\n                datesToProcess = datesToProcess.filter(date => \n                  getDate(date) === getDate(newPayment.startDate) && \n                  date.getMonth() === newPayment.startDate.getMonth()\n                );\n                break;\n            }\n            break;\n        }\n        \n        // Create entries for dates\n        const newEntries: FinancialEntry[] = datesToProcess.map(date => ({\n          id: uuidv4(),\n          date: new Date(date),\n          amount: newPayment.amount,\n          description: `[Recurring] ${newPayment.description}`,\n          type: newPayment.type\n        }));\n        \n        if (newEntries.length > 0) {\n          setEntries(prevEntries => [...prevEntries, ...newEntries]);\n        }\n      }\n    }\n    \n    setRecurringPayments(prevPayments => [...prevPayments, newPayment]);\n  };\n\n  // Update an existing recurring payment\n  const updateRecurringPayment = (updatedPayment: RecurringPayment) => {\n    setRecurringPayments(prevPayments =>\n      prevPayments.map(payment =>\n        payment.id === updatedPayment.id ? updatedPayment : payment\n      )\n    );\n  };\n\n  // Delete a recurring payment\n  const deleteRecurringPayment = (id: string) => {\n    setRecurringPayments(prevPayments => \n      prevPayments.filter(payment => payment.id !== id)\n    );\n  };\n\n  return {\n    entries,\n    addEntry,\n    updateEntry,\n    deleteEntry,\n    recurringPayments,\n    addRecurringPayment,\n    updateRecurringPayment,\n    deleteRecurringPayment,\n    monthData,\n    yearData,\n  };\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}