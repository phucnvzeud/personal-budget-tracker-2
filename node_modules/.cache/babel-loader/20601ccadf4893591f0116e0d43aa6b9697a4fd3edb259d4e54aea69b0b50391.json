{"ast":null,"code":"import{useState,useEffect,useMemo}from'react';import{v4 as uuidv4}from'uuid';import{format,startOfMonth,endOfMonth,eachDayOfInterval,isAfter,isBefore,isSameDay,isWeekend,getDate}from'date-fns';import{useAuth}from'../context/AuthContext';import axios from'axios';// Setup API base URL - will default to localhost for development\nconst API_URL=process.env.REACT_APP_API_URL||'http://localhost:8081';// Helper function to safely handle date serialization\nconst dateReviver=(key,value)=>{if(key==='date'||key==='startDate'||key==='endDate'||key==='validFrom'||key==='validUntil'){return new Date(value);}return value;};export const useFinancialData=function(){let currentDate=arguments.length>0&&arguments[0]!==undefined?arguments[0]:new Date();const{currentUser,token}=useAuth();const[entries,setEntries]=useState([]);const[recurringPayments,setRecurringPayments]=useState([]);const[isLoading,setIsLoading]=useState(true);const[error,setError]=useState(null);// Load entries from API\nuseEffect(()=>{const loadEntries=async()=>{if(!currentUser||!token){setEntries([]);return;}try{setIsLoading(true);const response=await axios.get(`${API_URL}/api/entries`);// Convert string dates to Date objects\nconst processedEntries=response.data.map(entry=>({...entry,id:entry._id||entry.id,// Handle MongoDB _id\ndate:new Date(entry.date)}));setEntries(processedEntries);setError(null);}catch(err){console.error('Error loading entries:',err);setError(err.message||'Failed to load financial entries');}finally{setIsLoading(false);}};loadEntries();},[currentUser,token]);// Load recurring payments from API\nuseEffect(()=>{const loadRecurringPayments=async()=>{if(!currentUser||!token){setRecurringPayments([]);return;}try{setIsLoading(true);const response=await axios.get(`${API_URL}/api/recurring-payments`);// Convert string dates to Date objects\nconst processedPayments=response.data.map(payment=>({...payment,id:payment._id||payment.id,// Handle MongoDB _id\nstartDate:new Date(payment.startDate),endDate:payment.endDate?new Date(payment.endDate):undefined,validFrom:new Date(payment.validFrom),validUntil:payment.validUntil?new Date(payment.validUntil):undefined}));setRecurringPayments(processedPayments);setError(null);}catch(err){console.error('Error loading recurring payments:',err);setError(err.message||'Failed to load recurring payments');}finally{setIsLoading(false);}};loadRecurringPayments();},[currentUser,token]);// Process recurring payments and generate entries\nuseEffect(()=>{const processRecurringPayments=()=>{// Current actual date (today)\nconst today=new Date();today.setHours(0,0,0,0);// Selected month in the UI (might be different from current month)\nconst selectedMonthStart=startOfMonth(currentDate);const selectedMonthEnd=endOfMonth(currentDate);// Consider a period of up to 30 days in the past from today (for historical data)\nconst pastProcessingDate=new Date(today);pastProcessingDate.setDate(pastProcessingDate.getDate()-30);// The start of processing should be the earlier of:\n// 1. 30 days before today (for recent past entries)\n// 2. The start of the selected month (for viewing past/future months)\nconst startDate=new Date(Math.min(pastProcessingDate.getTime(),selectedMonthStart.getTime()));// The end of processing should be the later of:\n// 1. The end of the current actual month (for immediate visibility)\n// 2. The end of the selected month (for viewing past/future months)\nconst endDate=new Date(Math.max(endOfMonth(today).getTime(),selectedMonthEnd.getTime()));// Prepare new entries generated from recurring payments\nconst newEntries=[];// Loop through all recurring payments\nrecurringPayments.forEach(payment=>{if(!payment.isActive)return;// Check if the payment is valid during any part of our processing window\nconst paymentEndDate=payment.validUntil||new Date(9999,11,31);// If no end date, use far future\n// If the payment's validity period doesn't overlap with our processing period, skip it\nif(isAfter(payment.validFrom,endDate)||isBefore(paymentEndDate,startDate)){return;}// Get dates to process based on schedule type\nlet datesToProcess=[];// Define start date for processing (max of payment's start date or our processing window start)\nconst processingStart=new Date(Math.max(payment.startDate.getTime(),startDate.getTime()));// Define end date for processing (min of payment's end date or processing window end)\nconst processingEnd=payment.endDate&&isBefore(payment.endDate,endDate)?payment.endDate:endDate;// Don't process if the processing period is invalid\nif(isAfter(processingStart,processingEnd))return;// Get candidate dates based on schedule type\nswitch(payment.scheduleType){case'specific-date':// For monthly payments on a specific day of month\nif(payment.frequency==='monthly'&&payment.dayOfMonth){// Get all days in the processing range\nconst allDays=eachDayOfInterval({start:processingStart,end:processingEnd});// Filter for days that match the day of month\ndatesToProcess=allDays.filter(date=>getDate(date)===payment.dayOfMonth);}// For yearly payments on a specific day of a specific month\nelse if(payment.frequency==='yearly'&&payment.dayOfMonth){// Get all days in the processing range\nconst allDays=eachDayOfInterval({start:processingStart,end:processingEnd});// Filter for days that match both the month and day\ndatesToProcess=allDays.filter(date=>getDate(date)===payment.dayOfMonth&&date.getMonth()===payment.startDate.getMonth());}break;case'weekdays-only':// Get all weekdays within the processing window\ndatesToProcess=eachDayOfInterval({start:processingStart,end:processingEnd}).filter(date=>!isWeekend(date));break;case'weekends-only':// Get all weekend days within the processing window\ndatesToProcess=eachDayOfInterval({start:processingStart,end:processingEnd}).filter(date=>isWeekend(date));break;case'custom-range':// Get all dates within the custom range\ndatesToProcess=eachDayOfInterval({start:processingStart,end:processingEnd});// Apply frequency filtering\nswitch(payment.frequency){case'daily':// All days are included, so no additional filtering\nbreak;case'weekly':// Keep only days whose day of week matches the original start date\ndatesToProcess=datesToProcess.filter(date=>date.getDay()===payment.startDate.getDay());break;case'monthly':// Keep only days whose day of month matches the original start date\ndatesToProcess=datesToProcess.filter(date=>getDate(date)===getDate(payment.startDate));break;case'yearly':// Keep only days whose day and month match the original start date\ndatesToProcess=datesToProcess.filter(date=>getDate(date)===getDate(payment.startDate)&&date.getMonth()===payment.startDate.getMonth());break;}break;}// Create entries for each date to process\ndatesToProcess.forEach(date=>{// Check if an entry for this recurring payment already exists on this date\nconst entryExists=entries.some(entry=>isSameDay(entry.date,date)&&entry.description===`[Recurring] ${payment.description}`);if(!entryExists){// Create a new entry for this recurring payment\nnewEntries.push({id:uuidv4(),date:new Date(date),amount:payment.amount,description:`[Recurring] ${payment.description}`,type:payment.type});}});});// Add new entries if any were generated\nif(newEntries.length>0){// First, save the entries to the API\nPromise.all(newEntries.map(entry=>axios.post(`${API_URL}/api/entries`,{date:entry.date,amount:entry.amount,description:entry.description,type:entry.type}))).then(responses=>{// Get the saved entries with their server-generated IDs\nconst savedEntries=responses.map(response=>({...response.data,id:response.data._id||response.data.id,// Handle MongoDB _id\ndate:new Date(response.data.date)}));// Update the local state\nsetEntries(prevEntries=>[...prevEntries,...savedEntries]);}).catch(err=>{console.error('Failed to save generated recurring entries:',err);setError('Failed to save generated recurring entries');});}};// Process recurring payments\nif(recurringPayments.length>0&&currentUser&&token){processRecurringPayments();}},[recurringPayments,entries,currentDate,currentUser,token]);// Calculate month data\nconst monthData=useMemo(()=>{const startDate=startOfMonth(currentDate);const endDate=endOfMonth(currentDate);const daysInMonth=eachDayOfInterval({start:startDate,end:endDate});const days=daysInMonth.reduce((acc,day)=>{const formattedDate=format(day,'yyyy-MM-dd');const dayEntries=entries.filter(entry=>isSameDay(entry.date,day));const totalIncome=dayEntries.filter(entry=>entry.type==='income').reduce((sum,entry)=>sum+entry.amount,0);const totalExpenses=dayEntries.filter(entry=>entry.type==='expense').reduce((sum,entry)=>sum+entry.amount,0);acc[formattedDate]={date:day,entries:dayEntries,totalIncome,totalExpenses,dailyBalance:totalIncome-totalExpenses,runningBalance:0// Calculated after all days are processed\n};return acc;},{});// Calculate running balance\nlet runningBalance=0;for(const day of daysInMonth){const formattedDate=format(day,'yyyy-MM-dd');runningBalance+=days[formattedDate].dailyBalance;days[formattedDate].runningBalance=runningBalance;}// Calculate total income, expenses, and balance for the month\nconst totalIncome=Object.values(days).reduce((sum,day)=>sum+day.totalIncome,0);const totalExpenses=Object.values(days).reduce((sum,day)=>sum+day.totalExpenses,0);return{days,totalIncome,totalExpenses,monthlyBalance:totalIncome-totalExpenses};},[currentDate,entries]);// Calculate year data\nconst yearData=useMemo(()=>{const year=currentDate.getFullYear();const months=Array.from({length:12},(_,i)=>i);const monthSummaries=months.map(month=>{const monthEntries=entries.filter(entry=>entry.date.getFullYear()===year&&entry.date.getMonth()===month);const totalIncome=monthEntries.filter(entry=>entry.type==='income').reduce((sum,entry)=>sum+entry.amount,0);const totalExpenses=monthEntries.filter(entry=>entry.type==='expense').reduce((sum,entry)=>sum+entry.amount,0);return{month,year,totalIncome,totalExpenses,monthlyBalance:totalIncome-totalExpenses};});const totalIncome=monthSummaries.reduce((sum,month)=>sum+month.totalIncome,0);const totalExpenses=monthSummaries.reduce((sum,month)=>sum+month.totalExpenses,0);return{year,months:monthSummaries,totalIncome,totalExpenses,yearlyBalance:totalIncome-totalExpenses};},[currentDate,entries]);// Add a new financial entry\nconst addEntry=async entry=>{if(!currentUser||!token){setError('You must be logged in to add entries');return;}try{setIsLoading(true);const response=await axios.post(`${API_URL}/api/entries`,entry);const newEntry={...response.data,id:response.data._id||response.data.id,// Handle MongoDB _id\ndate:new Date(response.data.date)};setEntries(prevEntries=>[...prevEntries,newEntry]);setError(null);}catch(err){console.error('Error adding entry:',err);setError(err.message||'Failed to add entry');}finally{setIsLoading(false);}};// Update an existing financial entry\nconst updateEntry=async updatedEntry=>{if(!currentUser||!token){setError('You must be logged in to update entries');return;}try{setIsLoading(true);// Use the MongoDB _id format for the API call\nconst entryId=updatedEntry._id||updatedEntry.id;const{_id,id,...entryData}=updatedEntry;// Remove both id fields for the API\nconst response=await axios.put(`${API_URL}/api/entries/${entryId}`,entryData);const savedEntry={...response.data,id:response.data._id||response.data.id,// Keep the id field for the frontend\ndate:new Date(response.data.date)};setEntries(prevEntries=>prevEntries.map(entry=>entry.id===savedEntry.id?savedEntry:entry));setError(null);}catch(err){console.error('Error updating entry:',err);setError(err.message||'Failed to update entry');}finally{setIsLoading(false);}};// Delete a financial entry\nconst deleteEntry=async id=>{if(!currentUser||!token){setError('You must be logged in to delete entries');return;}try{setIsLoading(true);await axios.delete(`${API_URL}/api/entries/${id}`);setEntries(prevEntries=>prevEntries.filter(entry=>entry.id!==id));setError(null);}catch(err){console.error('Error deleting entry:',err);setError(err.message||'Failed to delete entry');}finally{setIsLoading(false);}};// Add a recurring payment\nconst addRecurringPayment=async payment=>{if(!currentUser||!token){setError('You must be logged in to add recurring payments');return;}try{setIsLoading(true);const response=await axios.post(`${API_URL}/api/recurring-payments`,payment);const newPayment={...response.data,id:response.data._id||response.data.id,// Handle MongoDB _id\nstartDate:new Date(response.data.startDate),endDate:response.data.endDate?new Date(response.data.endDate):undefined,validFrom:new Date(response.data.validFrom),validUntil:response.data.validUntil?new Date(response.data.validUntil):undefined};setRecurringPayments(prevPayments=>[...prevPayments,newPayment]);setError(null);}catch(err){console.error('Error adding recurring payment:',err);setError(err.message||'Failed to add recurring payment');}finally{setIsLoading(false);}};// Update a recurring payment\nconst updateRecurringPayment=async updatedPayment=>{if(!currentUser||!token){setError('You must be logged in to update recurring payments');return;}try{setIsLoading(true);// Use the MongoDB _id format for the API call\nconst paymentId=updatedPayment._id||updatedPayment.id;const{_id,id,...paymentData}=updatedPayment;// Remove both id fields for the API\nconst response=await axios.put(`${API_URL}/api/recurring-payments/${paymentId}`,paymentData);const savedPayment={...response.data,id:response.data._id||response.data.id,// Keep the id field for the frontend\nstartDate:new Date(response.data.startDate),endDate:response.data.endDate?new Date(response.data.endDate):undefined,validFrom:new Date(response.data.validFrom),validUntil:response.data.validUntil?new Date(response.data.validUntil):undefined};setRecurringPayments(prevPayments=>prevPayments.map(payment=>payment.id===savedPayment.id?savedPayment:payment));setError(null);}catch(err){console.error('Error updating recurring payment:',err);setError(err.message||'Failed to update recurring payment');}finally{setIsLoading(false);}};// Delete a recurring payment\nconst deleteRecurringPayment=async id=>{if(!currentUser||!token){setError('You must be logged in to delete recurring payments');return;}try{setIsLoading(true);await axios.delete(`${API_URL}/api/recurring-payments/${id}`);setRecurringPayments(prevPayments=>prevPayments.filter(payment=>payment.id!==id));setError(null);}catch(err){console.error('Error deleting recurring payment:',err);setError(err.message||'Failed to delete recurring payment');}finally{setIsLoading(false);}};return{entries,recurringPayments,monthData,yearData,addEntry,updateEntry,deleteEntry,addRecurringPayment,updateRecurringPayment,deleteRecurringPayment,isLoading,error};};","map":{"version":3,"names":["useState","useEffect","useMemo","v4","uuidv4","format","startOfMonth","endOfMonth","eachDayOfInterval","isAfter","isBefore","isSameDay","isWeekend","getDate","useAuth","axios","API_URL","process","env","REACT_APP_API_URL","dateReviver","key","value","Date","useFinancialData","currentDate","arguments","length","undefined","currentUser","token","entries","setEntries","recurringPayments","setRecurringPayments","isLoading","setIsLoading","error","setError","loadEntries","response","get","processedEntries","data","map","entry","id","_id","date","err","console","message","loadRecurringPayments","processedPayments","payment","startDate","endDate","validFrom","validUntil","processRecurringPayments","today","setHours","selectedMonthStart","selectedMonthEnd","pastProcessingDate","setDate","Math","min","getTime","max","newEntries","forEach","isActive","paymentEndDate","datesToProcess","processingStart","processingEnd","scheduleType","frequency","dayOfMonth","allDays","start","end","filter","getMonth","getDay","entryExists","some","description","push","amount","type","Promise","all","post","then","responses","savedEntries","prevEntries","catch","monthData","daysInMonth","days","reduce","acc","day","formattedDate","dayEntries","totalIncome","sum","totalExpenses","dailyBalance","runningBalance","Object","values","monthlyBalance","yearData","year","getFullYear","months","Array","from","_","i","monthSummaries","month","monthEntries","yearlyBalance","addEntry","newEntry","updateEntry","updatedEntry","entryId","entryData","put","savedEntry","deleteEntry","delete","addRecurringPayment","newPayment","prevPayments","updateRecurringPayment","updatedPayment","paymentId","paymentData","savedPayment","deleteRecurringPayment"],"sources":["C:/Users/Administrator/Downloads/personal-budget-tracker v2/personal-budget-tracker/src/hooks/useFinancialData.ts"],"sourcesContent":["import { useState, useEffect, useMemo, useCallback } from 'react';\nimport { \n  FinancialEntry, \n  RecurringPayment\n} from '../types';\nimport { v4 as uuidv4 } from 'uuid';\nimport { \n  format, \n  startOfMonth, \n  endOfMonth, \n  eachDayOfInterval, \n  isAfter, \n  isBefore, \n  isSameDay, \n  isWeekend,\n  getDate\n} from 'date-fns';\nimport { useAuth } from '../context/AuthContext';\nimport axios from 'axios';\n\n// Setup API base URL - will default to localhost for development\nconst API_URL = process.env.REACT_APP_API_URL || 'http://localhost:8081';\n\n// Helper function to safely handle date serialization\nconst dateReviver = (key: string, value: any) => {\n  if (key === 'date' || key === 'startDate' || key === 'endDate' || key === 'validFrom' || key === 'validUntil') {\n    return new Date(value);\n  }\n  return value;\n};\n\nexport const useFinancialData = (currentDate: Date = new Date()) => {\n  const { currentUser, token } = useAuth();\n  const [entries, setEntries] = useState<FinancialEntry[]>([]);\n  const [recurringPayments, setRecurringPayments] = useState<RecurringPayment[]>([]);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  // Load entries from API\n  useEffect(() => {\n    const loadEntries = async () => {\n      if (!currentUser || !token) {\n        setEntries([]);\n        return;\n      }\n\n      try {\n        setIsLoading(true);\n        const response = await axios.get(`${API_URL}/api/entries`);\n        \n        // Convert string dates to Date objects\n        const processedEntries = response.data.map((entry: any) => ({\n          ...entry,\n          id: entry._id || entry.id, // Handle MongoDB _id\n          date: new Date(entry.date)\n        }));\n        \n        setEntries(processedEntries);\n        setError(null);\n      } catch (err: any) {\n        console.error('Error loading entries:', err);\n        setError(err.message || 'Failed to load financial entries');\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    loadEntries();\n  }, [currentUser, token]);\n\n  // Load recurring payments from API\n  useEffect(() => {\n    const loadRecurringPayments = async () => {\n      if (!currentUser || !token) {\n        setRecurringPayments([]);\n        return;\n      }\n\n      try {\n        setIsLoading(true);\n        const response = await axios.get(`${API_URL}/api/recurring-payments`);\n        \n        // Convert string dates to Date objects\n        const processedPayments = response.data.map((payment: any) => ({\n          ...payment,\n          id: payment._id || payment.id, // Handle MongoDB _id\n          startDate: new Date(payment.startDate),\n          endDate: payment.endDate ? new Date(payment.endDate) : undefined,\n          validFrom: new Date(payment.validFrom),\n          validUntil: payment.validUntil ? new Date(payment.validUntil) : undefined\n        }));\n        \n        setRecurringPayments(processedPayments);\n        setError(null);\n      } catch (err: any) {\n        console.error('Error loading recurring payments:', err);\n        setError(err.message || 'Failed to load recurring payments');\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    loadRecurringPayments();\n  }, [currentUser, token]);\n\n  // Process recurring payments and generate entries\n  useEffect(() => {\n    const processRecurringPayments = () => {\n      // Current actual date (today)\n      const today = new Date();\n      today.setHours(0, 0, 0, 0);\n      \n      // Selected month in the UI (might be different from current month)\n      const selectedMonthStart = startOfMonth(currentDate);\n      const selectedMonthEnd = endOfMonth(currentDate);\n      \n      // Consider a period of up to 30 days in the past from today (for historical data)\n      const pastProcessingDate = new Date(today);\n      pastProcessingDate.setDate(pastProcessingDate.getDate() - 30);\n      \n      // The start of processing should be the earlier of:\n      // 1. 30 days before today (for recent past entries)\n      // 2. The start of the selected month (for viewing past/future months)\n      const startDate = new Date(Math.min(pastProcessingDate.getTime(), selectedMonthStart.getTime()));\n      \n      // The end of processing should be the later of:\n      // 1. The end of the current actual month (for immediate visibility)\n      // 2. The end of the selected month (for viewing past/future months)\n      const endDate = new Date(\n        Math.max(\n          endOfMonth(today).getTime(),\n          selectedMonthEnd.getTime()\n        )\n      );\n      \n      // Prepare new entries generated from recurring payments\n      const newEntries: FinancialEntry[] = [];\n\n      // Loop through all recurring payments\n      recurringPayments.forEach(payment => {\n        if (!payment.isActive) return;\n\n        // Check if the payment is valid during any part of our processing window\n        const paymentEndDate = payment.validUntil || new Date(9999, 11, 31); // If no end date, use far future\n        \n        // If the payment's validity period doesn't overlap with our processing period, skip it\n        if (isAfter(payment.validFrom, endDate) || isBefore(paymentEndDate, startDate)) {\n          return;\n        }\n\n        // Get dates to process based on schedule type\n        let datesToProcess: Date[] = [];\n        \n        // Define start date for processing (max of payment's start date or our processing window start)\n        const processingStart = new Date(Math.max(payment.startDate.getTime(), startDate.getTime()));\n        \n        // Define end date for processing (min of payment's end date or processing window end)\n        const processingEnd = payment.endDate && isBefore(payment.endDate, endDate) \n          ? payment.endDate \n          : endDate;\n\n        // Don't process if the processing period is invalid\n        if (isAfter(processingStart, processingEnd)) return;\n\n        // Get candidate dates based on schedule type\n        switch (payment.scheduleType) {\n          case 'specific-date':\n            // For monthly payments on a specific day of month\n            if (payment.frequency === 'monthly' && payment.dayOfMonth) {\n              // Get all days in the processing range\n              const allDays = eachDayOfInterval({ start: processingStart, end: processingEnd });\n              // Filter for days that match the day of month\n              datesToProcess = allDays.filter(date => getDate(date) === payment.dayOfMonth);\n            } \n            // For yearly payments on a specific day of a specific month\n            else if (payment.frequency === 'yearly' && payment.dayOfMonth) {\n              // Get all days in the processing range\n              const allDays = eachDayOfInterval({ start: processingStart, end: processingEnd });\n              // Filter for days that match both the month and day\n              datesToProcess = allDays.filter(date => \n                getDate(date) === payment.dayOfMonth &&\n                date.getMonth() === payment.startDate.getMonth()\n              );\n            }\n            break;\n            \n          case 'weekdays-only':\n            // Get all weekdays within the processing window\n            datesToProcess = eachDayOfInterval({ start: processingStart, end: processingEnd })\n              .filter(date => !isWeekend(date));\n            break;\n            \n          case 'weekends-only':\n            // Get all weekend days within the processing window\n            datesToProcess = eachDayOfInterval({ start: processingStart, end: processingEnd })\n              .filter(date => isWeekend(date));\n            break;\n            \n          case 'custom-range':\n            // Get all dates within the custom range\n            datesToProcess = eachDayOfInterval({ start: processingStart, end: processingEnd });\n            \n            // Apply frequency filtering\n            switch (payment.frequency) {\n              case 'daily':\n                // All days are included, so no additional filtering\n                break;\n                \n              case 'weekly':\n                // Keep only days whose day of week matches the original start date\n                datesToProcess = datesToProcess.filter(date => \n                  date.getDay() === payment.startDate.getDay()\n                );\n                break;\n                \n              case 'monthly':\n                // Keep only days whose day of month matches the original start date\n                datesToProcess = datesToProcess.filter(date => \n                  getDate(date) === getDate(payment.startDate)\n                );\n                break;\n                \n              case 'yearly':\n                // Keep only days whose day and month match the original start date\n                datesToProcess = datesToProcess.filter(date => \n                  getDate(date) === getDate(payment.startDate) && \n                  date.getMonth() === payment.startDate.getMonth()\n                );\n                break;\n            }\n            break;\n        }\n\n        // Create entries for each date to process\n        datesToProcess.forEach(date => {\n          // Check if an entry for this recurring payment already exists on this date\n          const entryExists = entries.some(entry => \n            isSameDay(entry.date, date) && \n            entry.description === `[Recurring] ${payment.description}`\n          );\n\n          if (!entryExists) {\n            // Create a new entry for this recurring payment\n            newEntries.push({\n              id: uuidv4(),\n              date: new Date(date),\n              amount: payment.amount,\n              description: `[Recurring] ${payment.description}`,\n              type: payment.type\n            });\n          }\n        });\n      });\n\n      // Add new entries if any were generated\n      if (newEntries.length > 0) {\n        // First, save the entries to the API\n        Promise.all(\n          newEntries.map(entry => \n            axios.post(`${API_URL}/api/entries`, {\n              date: entry.date,\n              amount: entry.amount,\n              description: entry.description,\n              type: entry.type\n            })\n          )\n        )\n        .then(responses => {\n          // Get the saved entries with their server-generated IDs\n          const savedEntries = responses.map(response => ({\n            ...response.data,\n            id: response.data._id || response.data.id, // Handle MongoDB _id\n            date: new Date(response.data.date)\n          }));\n          \n          // Update the local state\n          setEntries(prevEntries => [...prevEntries, ...savedEntries]);\n        })\n        .catch(err => {\n          console.error('Failed to save generated recurring entries:', err);\n          setError('Failed to save generated recurring entries');\n        });\n      }\n    };\n\n    // Process recurring payments\n    if (recurringPayments.length > 0 && currentUser && token) {\n      processRecurringPayments();\n    }\n  }, [recurringPayments, entries, currentDate, currentUser, token]);\n\n  // Calculate month data\n  const monthData = useMemo(() => {\n    const startDate = startOfMonth(currentDate);\n    const endDate = endOfMonth(currentDate);\n    const daysInMonth = eachDayOfInterval({ start: startDate, end: endDate });\n\n    const days = daysInMonth.reduce((acc, day) => {\n      const formattedDate = format(day, 'yyyy-MM-dd');\n      const dayEntries = entries.filter(entry => isSameDay(entry.date, day));\n      \n      const totalIncome = dayEntries\n        .filter(entry => entry.type === 'income')\n        .reduce((sum, entry) => sum + entry.amount, 0);\n      \n      const totalExpenses = dayEntries\n        .filter(entry => entry.type === 'expense')\n        .reduce((sum, entry) => sum + entry.amount, 0);\n\n      acc[formattedDate] = {\n        date: day,\n        entries: dayEntries,\n        totalIncome,\n        totalExpenses,\n        dailyBalance: totalIncome - totalExpenses,\n        runningBalance: 0, // Calculated after all days are processed\n      };\n\n      return acc;\n    }, {} as Record<string, any>);\n\n    // Calculate running balance\n    let runningBalance = 0;\n    for (const day of daysInMonth) {\n      const formattedDate = format(day, 'yyyy-MM-dd');\n      runningBalance += days[formattedDate].dailyBalance;\n      days[formattedDate].runningBalance = runningBalance;\n    }\n\n    // Calculate total income, expenses, and balance for the month\n    const totalIncome = Object.values(days).reduce(\n      (sum, day: any) => sum + day.totalIncome,\n      0\n    );\n    const totalExpenses = Object.values(days).reduce(\n      (sum, day: any) => sum + day.totalExpenses,\n      0\n    );\n\n    return {\n      days,\n      totalIncome,\n      totalExpenses,\n      monthlyBalance: totalIncome - totalExpenses,\n    };\n  }, [currentDate, entries]);\n\n  // Calculate year data\n  const yearData = useMemo(() => {\n    const year = currentDate.getFullYear();\n    const months = Array.from({ length: 12 }, (_, i) => i);\n\n    const monthSummaries = months.map(month => {\n      const monthEntries = entries.filter(entry => \n        entry.date.getFullYear() === year && \n        entry.date.getMonth() === month\n      );\n\n      const totalIncome = monthEntries\n        .filter(entry => entry.type === 'income')\n        .reduce((sum, entry) => sum + entry.amount, 0);\n      \n      const totalExpenses = monthEntries\n        .filter(entry => entry.type === 'expense')\n        .reduce((sum, entry) => sum + entry.amount, 0);\n\n      return {\n        month,\n        year,\n        totalIncome,\n        totalExpenses,\n        monthlyBalance: totalIncome - totalExpenses,\n      };\n    });\n\n    const totalIncome = monthSummaries.reduce(\n      (sum, month) => sum + month.totalIncome,\n      0\n    );\n    const totalExpenses = monthSummaries.reduce(\n      (sum, month) => sum + month.totalExpenses,\n      0\n    );\n\n    return {\n      year,\n      months: monthSummaries,\n      totalIncome,\n      totalExpenses,\n      yearlyBalance: totalIncome - totalExpenses,\n    };\n  }, [currentDate, entries]);\n\n  // Add a new financial entry\n  const addEntry = async (entry: Omit<FinancialEntry, 'id'>) => {\n    if (!currentUser || !token) {\n      setError('You must be logged in to add entries');\n      return;\n    }\n    \n    try {\n      setIsLoading(true);\n      const response = await axios.post(`${API_URL}/api/entries`, entry);\n      \n      const newEntry = {\n        ...response.data,\n        id: response.data._id || response.data.id, // Handle MongoDB _id\n        date: new Date(response.data.date)\n      };\n      \n      setEntries(prevEntries => [...prevEntries, newEntry]);\n      setError(null);\n    } catch (err: any) {\n      console.error('Error adding entry:', err);\n      setError(err.message || 'Failed to add entry');\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  // Update an existing financial entry\n  const updateEntry = async (updatedEntry: FinancialEntry) => {\n    if (!currentUser || !token) {\n      setError('You must be logged in to update entries');\n      return;\n    }\n    \n    try {\n      setIsLoading(true);\n      \n      // Use the MongoDB _id format for the API call\n      const entryId = updatedEntry._id || updatedEntry.id;\n      const { _id, id, ...entryData } = updatedEntry; // Remove both id fields for the API\n      \n      const response = await axios.put(`${API_URL}/api/entries/${entryId}`, entryData);\n      \n      const savedEntry = {\n        ...response.data,\n        id: response.data._id || response.data.id, // Keep the id field for the frontend\n        date: new Date(response.data.date)\n      };\n      \n      setEntries(prevEntries =>\n        prevEntries.map(entry => \n          entry.id === savedEntry.id ? savedEntry : entry\n        )\n      );\n      \n      setError(null);\n    } catch (err: any) {\n      console.error('Error updating entry:', err);\n      setError(err.message || 'Failed to update entry');\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  // Delete a financial entry\n  const deleteEntry = async (id: string) => {\n    if (!currentUser || !token) {\n      setError('You must be logged in to delete entries');\n      return;\n    }\n    \n    try {\n      setIsLoading(true);\n      await axios.delete(`${API_URL}/api/entries/${id}`);\n      \n      setEntries(prevEntries => prevEntries.filter(entry => entry.id !== id));\n      setError(null);\n    } catch (err: any) {\n      console.error('Error deleting entry:', err);\n      setError(err.message || 'Failed to delete entry');\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  // Add a recurring payment\n  const addRecurringPayment = async (payment: Omit<RecurringPayment, 'id'>) => {\n    if (!currentUser || !token) {\n      setError('You must be logged in to add recurring payments');\n      return;\n    }\n    \n    try {\n      setIsLoading(true);\n      const response = await axios.post(`${API_URL}/api/recurring-payments`, payment);\n      \n      const newPayment = {\n        ...response.data,\n        id: response.data._id || response.data.id, // Handle MongoDB _id\n        startDate: new Date(response.data.startDate),\n        endDate: response.data.endDate ? new Date(response.data.endDate) : undefined,\n        validFrom: new Date(response.data.validFrom),\n        validUntil: response.data.validUntil ? new Date(response.data.validUntil) : undefined\n      };\n      \n      setRecurringPayments(prevPayments => [...prevPayments, newPayment]);\n      setError(null);\n    } catch (err: any) {\n      console.error('Error adding recurring payment:', err);\n      setError(err.message || 'Failed to add recurring payment');\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  // Update a recurring payment\n  const updateRecurringPayment = async (updatedPayment: RecurringPayment) => {\n    if (!currentUser || !token) {\n      setError('You must be logged in to update recurring payments');\n      return;\n    }\n    \n    try {\n      setIsLoading(true);\n      \n      // Use the MongoDB _id format for the API call\n      const paymentId = updatedPayment._id || updatedPayment.id;\n      const { _id, id, ...paymentData } = updatedPayment; // Remove both id fields for the API\n      \n      const response = await axios.put(`${API_URL}/api/recurring-payments/${paymentId}`, paymentData);\n      \n      const savedPayment = {\n        ...response.data,\n        id: response.data._id || response.data.id, // Keep the id field for the frontend\n        startDate: new Date(response.data.startDate),\n        endDate: response.data.endDate ? new Date(response.data.endDate) : undefined,\n        validFrom: new Date(response.data.validFrom),\n        validUntil: response.data.validUntil ? new Date(response.data.validUntil) : undefined\n      };\n      \n      setRecurringPayments(prevPayments =>\n        prevPayments.map(payment => \n          payment.id === savedPayment.id ? savedPayment : payment\n        )\n      );\n      \n      setError(null);\n    } catch (err: any) {\n      console.error('Error updating recurring payment:', err);\n      setError(err.message || 'Failed to update recurring payment');\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  // Delete a recurring payment\n  const deleteRecurringPayment = async (id: string) => {\n    if (!currentUser || !token) {\n      setError('You must be logged in to delete recurring payments');\n      return;\n    }\n    \n    try {\n      setIsLoading(true);\n      await axios.delete(`${API_URL}/api/recurring-payments/${id}`);\n      \n      setRecurringPayments(prevPayments => prevPayments.filter(payment => payment.id !== id));\n      setError(null);\n    } catch (err: any) {\n      console.error('Error deleting recurring payment:', err);\n      setError(err.message || 'Failed to delete recurring payment');\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  return {\n    entries,\n    recurringPayments,\n    monthData,\n    yearData,\n    addEntry,\n    updateEntry,\n    deleteEntry,\n    addRecurringPayment,\n    updateRecurringPayment,\n    deleteRecurringPayment,\n    isLoading,\n    error\n  };\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}