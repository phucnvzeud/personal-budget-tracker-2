{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useMemo } from 'react';\nimport { v4 as uuidv4 } from 'uuid';\nimport { format, startOfMonth, endOfMonth, eachDayOfInterval, isAfter, isBefore, isSameDay, isWeekend, getDate } from 'date-fns';\nimport { useAuth } from '../context/AuthContext';\nconst ENTRIES_STORAGE_KEY = 'personal-budget-tracker-entries';\nconst RECURRING_PAYMENTS_STORAGE_KEY = 'personal-budget-tracker-recurring-payments';\n\n// Helper function to safely handle date serialization\nconst dateReviver = (key, value) => {\n  if (key === 'date' || key === 'startDate' || key === 'endDate') {\n    return new Date(value);\n  }\n  return value;\n};\nexport const useFinancialData = (currentDate = new Date()) => {\n  _s();\n  const {\n    currentUser\n  } = useAuth();\n  const [entries, setEntries] = useState([]);\n  const [recurringPayments, setRecurringPayments] = useState([]);\n\n  // Get storage key for the current user\n  const getStorageKey = key => {\n    return currentUser ? `${key}-${currentUser.id}` : key;\n  };\n\n  // Load entries from localStorage\n  useEffect(() => {\n    const savedEntries = localStorage.getItem(getStorageKey(ENTRIES_STORAGE_KEY));\n    if (savedEntries) {\n      const parsedEntries = JSON.parse(savedEntries, dateReviver);\n      setEntries(parsedEntries.map(entry => ({\n        ...entry,\n        date: new Date(entry.date)\n      })));\n    }\n  }, [getStorageKey]);\n\n  // Save entries to localStorage\n  useEffect(() => {\n    if (entries.length > 0) {\n      localStorage.setItem(getStorageKey(ENTRIES_STORAGE_KEY), JSON.stringify(entries));\n    }\n  }, [entries, getStorageKey]);\n\n  // Load recurring payments from localStorage\n  useEffect(() => {\n    const savedRecurringPayments = localStorage.getItem(getStorageKey(RECURRING_PAYMENTS_STORAGE_KEY));\n    if (savedRecurringPayments) {\n      const parsedPayments = JSON.parse(savedRecurringPayments, dateReviver);\n      setRecurringPayments(parsedPayments.map(payment => ({\n        ...payment,\n        startDate: new Date(payment.startDate),\n        endDate: payment.endDate ? new Date(payment.endDate) : undefined,\n        validFrom: new Date(payment.validFrom),\n        validUntil: payment.validUntil ? new Date(payment.validUntil) : undefined\n      })));\n    }\n  }, [getStorageKey]);\n\n  // Save recurring payments to localStorage\n  useEffect(() => {\n    if (recurringPayments.length > 0) {\n      localStorage.setItem(getStorageKey(RECURRING_PAYMENTS_STORAGE_KEY), JSON.stringify(recurringPayments));\n    }\n  }, [recurringPayments, getStorageKey]);\n\n  // Process recurring payments and generate entries for the entire month\n  useEffect(() => {\n    const processRecurringPayments = () => {\n      // Get current date without time\n      const today = new Date();\n      today.setHours(0, 0, 0, 0);\n\n      // Process entries for the current viewed month\n      const monthStart = startOfMonth(currentDate);\n      const monthEnd = endOfMonth(currentDate);\n\n      // Prepare new entries generated from recurring payments\n      const newEntries = [];\n\n      // Loop through all recurring payments\n      recurringPayments.forEach(payment => {\n        if (!payment.isActive) return;\n\n        // Check if the payment is currently valid\n        const isValid = isWithinDateRange(today, payment.validFrom, payment.validUntil || new Date(9999, 11, 31) // If no end date, use far future\n        );\n        if (!isValid) return;\n\n        // Get dates to process based on schedule type\n        let datesToProcess = [];\n\n        // Define start date for processing (max of payment's start date or month start)\n        const processingStart = new Date(Math.max(payment.startDate.getTime(), monthStart.getTime()));\n\n        // Define end date for processing (min of payment's end date, month end, or today)\n        const processingEnd = new Date(Math.min(payment.endDate ? payment.endDate.getTime() : 9999999999999, monthEnd.getTime(), today.getTime()));\n\n        // Don't process if the processing period is invalid\n        if (isAfter(processingStart, processingEnd)) return;\n\n        // Get candidate dates based on schedule type\n        switch (payment.scheduleType) {\n          case 'specific-date':\n            // For monthly payments on a specific day of month\n            if (payment.frequency === 'monthly' && payment.dayOfMonth) {\n              // If today's day matches the payment day, and we haven't created this entry before\n              if (getDate(today) === payment.dayOfMonth) {\n                datesToProcess.push(new Date(today));\n              }\n            }\n            // For yearly payments on a specific day of a specific month\n            else if (payment.frequency === 'yearly' && payment.dayOfMonth) {\n              const paymentDate = new Date(today.getFullYear(), payment.startDate.getMonth(), payment.dayOfMonth);\n\n              // If today's date matches the yearly payment date\n              if (isSameDay(today, paymentDate)) {\n                datesToProcess.push(new Date(today));\n              }\n            }\n            break;\n          case 'weekdays-only':\n            // Get all weekdays within the processing window\n            datesToProcess = eachDayOfInterval({\n              start: processingStart,\n              end: processingEnd\n            }).filter(date => !isWeekend(date));\n            break;\n          case 'weekends-only':\n            // Get all weekend days within the processing window\n            datesToProcess = eachDayOfInterval({\n              start: processingStart,\n              end: processingEnd\n            }).filter(date => isWeekend(date));\n            break;\n          case 'custom-range':\n            // Get all dates within the custom range\n            datesToProcess = eachDayOfInterval({\n              start: processingStart,\n              end: processingEnd\n            });\n\n            // Apply frequency filtering\n            switch (payment.frequency) {\n              case 'daily':\n                // All days are included, so no additional filtering\n                break;\n              case 'weekly':\n                // Keep only days whose day of week matches the original start date\n                datesToProcess = datesToProcess.filter(date => date.getDay() === payment.startDate.getDay());\n                break;\n              case 'monthly':\n                // Keep only days whose day of month matches the original start date\n                datesToProcess = datesToProcess.filter(date => getDate(date) === getDate(payment.startDate));\n                break;\n              case 'yearly':\n                // Keep only days whose day and month match the original start date\n                datesToProcess = datesToProcess.filter(date => getDate(date) === getDate(payment.startDate) && date.getMonth() === payment.startDate.getMonth());\n                break;\n            }\n            break;\n        }\n\n        // Create entries for each date to process\n        datesToProcess.forEach(date => {\n          // Check if an entry for this recurring payment already exists on this date\n          const entryExists = entries.some(entry => isSameDay(entry.date, date) && entry.description === `[Recurring] ${payment.description}`);\n          if (!entryExists) {\n            // Create a new entry for this recurring payment\n            newEntries.push({\n              id: uuidv4(),\n              date: new Date(date),\n              amount: payment.amount,\n              description: `[Recurring] ${payment.description}`,\n              type: payment.type\n            });\n          }\n        });\n      });\n\n      // Add new entries if any were generated\n      if (newEntries.length > 0) {\n        setEntries(prevEntries => [...prevEntries, ...newEntries]);\n      }\n    };\n\n    // Process recurring payments\n    if (recurringPayments.length > 0) {\n      processRecurringPayments();\n    }\n  }, [recurringPayments, entries, currentDate]);\n\n  // Helper function to check if a date is within a date range\n  const isWithinDateRange = (date, start, end) => {\n    return (isSameDay(date, start) || isAfter(date, start)) && (isSameDay(date, end) || isBefore(date, end));\n  };\n\n  // Calculate month data\n  const monthData = useMemo(() => {\n    const startDate = startOfMonth(currentDate);\n    const endDate = endOfMonth(currentDate);\n    const daysInMonth = eachDayOfInterval({\n      start: startDate,\n      end: endDate\n    });\n    const days = daysInMonth.reduce((acc, day) => {\n      const formattedDate = format(day, 'yyyy-MM-dd');\n      const dayEntries = entries.filter(entry => isSameDay(entry.date, day));\n      const totalIncome = dayEntries.filter(entry => entry.type === 'income').reduce((sum, entry) => sum + entry.amount, 0);\n      const totalExpenses = dayEntries.filter(entry => entry.type === 'expense').reduce((sum, entry) => sum + entry.amount, 0);\n      acc[formattedDate] = {\n        date: day,\n        entries: dayEntries,\n        totalIncome,\n        totalExpenses,\n        dailyBalance: totalIncome - totalExpenses,\n        runningBalance: 0 // Calculated after all days are processed\n      };\n      return acc;\n    }, {});\n\n    // Calculate running balance\n    let runningBalance = 0;\n    for (const day of daysInMonth) {\n      const formattedDate = format(day, 'yyyy-MM-dd');\n      runningBalance += days[formattedDate].dailyBalance;\n      days[formattedDate].runningBalance = runningBalance;\n    }\n\n    // Calculate total income, expenses, and balance for the month\n    const totalIncome = Object.values(days).reduce((sum, day) => sum + day.totalIncome, 0);\n    const totalExpenses = Object.values(days).reduce((sum, day) => sum + day.totalExpenses, 0);\n    return {\n      days,\n      totalIncome,\n      totalExpenses,\n      monthlyBalance: totalIncome - totalExpenses\n    };\n  }, [currentDate, entries]);\n\n  // Calculate year data\n  const yearData = useMemo(() => {\n    const year = currentDate.getFullYear();\n    const months = Array.from({\n      length: 12\n    }, (_, i) => i);\n    const monthSummaries = months.map(month => {\n      const monthEntries = entries.filter(entry => entry.date.getFullYear() === year && entry.date.getMonth() === month);\n      const totalIncome = monthEntries.filter(entry => entry.type === 'income').reduce((sum, entry) => sum + entry.amount, 0);\n      const totalExpenses = monthEntries.filter(entry => entry.type === 'expense').reduce((sum, entry) => sum + entry.amount, 0);\n      return {\n        month,\n        year,\n        totalIncome,\n        totalExpenses,\n        monthlyBalance: totalIncome - totalExpenses\n      };\n    });\n    const totalIncome = monthSummaries.reduce((sum, month) => sum + month.totalIncome, 0);\n    const totalExpenses = monthSummaries.reduce((sum, month) => sum + month.totalExpenses, 0);\n    return {\n      year,\n      months: monthSummaries,\n      totalIncome,\n      totalExpenses,\n      yearlyBalance: totalIncome - totalExpenses\n    };\n  }, [currentDate, entries]);\n\n  // Add a new financial entry\n  const addEntry = entry => {\n    const newEntry = {\n      ...entry,\n      id: uuidv4()\n    };\n    setEntries(prevEntries => [...prevEntries, newEntry]);\n  };\n\n  // Update an existing financial entry\n  const updateEntry = updatedEntry => {\n    setEntries(prevEntries => prevEntries.map(entry => entry.id === updatedEntry.id ? updatedEntry : entry));\n  };\n\n  // Delete a financial entry\n  const deleteEntry = id => {\n    setEntries(prevEntries => prevEntries.filter(entry => entry.id !== id));\n  };\n\n  // Add a new recurring payment\n  const addRecurringPayment = payment => {\n    const newPayment = {\n      ...payment,\n      id: uuidv4()\n    };\n    setRecurringPayments(prevPayments => [...prevPayments, newPayment]);\n  };\n\n  // Update an existing recurring payment\n  const updateRecurringPayment = updatedPayment => {\n    setRecurringPayments(prevPayments => prevPayments.map(payment => payment.id === updatedPayment.id ? updatedPayment : payment));\n  };\n\n  // Delete a recurring payment\n  const deleteRecurringPayment = id => {\n    setRecurringPayments(prevPayments => prevPayments.filter(payment => payment.id !== id));\n  };\n  return {\n    entries,\n    addEntry,\n    updateEntry,\n    deleteEntry,\n    recurringPayments,\n    addRecurringPayment,\n    updateRecurringPayment,\n    deleteRecurringPayment,\n    monthData,\n    yearData\n  };\n};\n_s(useFinancialData, \"aPhJgDWCrnE9bmisuKvc8OPXkzg=\", false, function () {\n  return [useAuth];\n});","map":{"version":3,"names":["useState","useEffect","useMemo","v4","uuidv4","format","startOfMonth","endOfMonth","eachDayOfInterval","isAfter","isBefore","isSameDay","isWeekend","getDate","useAuth","ENTRIES_STORAGE_KEY","RECURRING_PAYMENTS_STORAGE_KEY","dateReviver","key","value","Date","useFinancialData","currentDate","_s","currentUser","entries","setEntries","recurringPayments","setRecurringPayments","getStorageKey","id","savedEntries","localStorage","getItem","parsedEntries","JSON","parse","map","entry","date","length","setItem","stringify","savedRecurringPayments","parsedPayments","payment","startDate","endDate","undefined","validFrom","validUntil","processRecurringPayments","today","setHours","monthStart","monthEnd","newEntries","forEach","isActive","isValid","isWithinDateRange","datesToProcess","processingStart","Math","max","getTime","processingEnd","min","scheduleType","frequency","dayOfMonth","push","paymentDate","getFullYear","getMonth","start","end","filter","getDay","entryExists","some","description","amount","type","prevEntries","monthData","daysInMonth","days","reduce","acc","day","formattedDate","dayEntries","totalIncome","sum","totalExpenses","dailyBalance","runningBalance","Object","values","monthlyBalance","yearData","year","months","Array","from","_","i","monthSummaries","month","monthEntries","yearlyBalance","addEntry","newEntry","updateEntry","updatedEntry","deleteEntry","addRecurringPayment","newPayment","prevPayments","updateRecurringPayment","updatedPayment","deleteRecurringPayment"],"sources":["C:/Users/Administrator/Downloads/personal-budget-tracker/src/hooks/useFinancialData.ts"],"sourcesContent":["import { useState, useEffect, useMemo } from 'react';\nimport { \n  FinancialEntry, \n  MonthData, \n  YearData, \n  RecurringPayment, \n  RecurringScheduleType \n} from '../types';\nimport { v4 as uuidv4 } from 'uuid';\nimport { \n  format, \n  startOfMonth, \n  endOfMonth, \n  eachDayOfInterval, \n  isAfter, \n  isBefore, \n  isSameDay, \n  isWithinInterval,\n  addDays,\n  isSameMonth,\n  isSameYear,\n  isWeekend,\n  getDate\n} from 'date-fns';\nimport { useAuth } from '../context/AuthContext';\n\nconst ENTRIES_STORAGE_KEY = 'personal-budget-tracker-entries';\nconst RECURRING_PAYMENTS_STORAGE_KEY = 'personal-budget-tracker-recurring-payments';\n\n// Helper function to safely handle date serialization\nconst dateReviver = (key: string, value: any) => {\n  if (key === 'date' || key === 'startDate' || key === 'endDate') {\n    return new Date(value);\n  }\n  return value;\n};\n\nexport const useFinancialData = (currentDate: Date = new Date()) => {\n  const { currentUser } = useAuth();\n  const [entries, setEntries] = useState<FinancialEntry[]>([]);\n  const [recurringPayments, setRecurringPayments] = useState<RecurringPayment[]>([]);\n\n  // Get storage key for the current user\n  const getStorageKey = (key: string) => {\n    return currentUser \n      ? `${key}-${currentUser.id}`\n      : key;\n  };\n\n  // Load entries from localStorage\n  useEffect(() => {\n    const savedEntries = localStorage.getItem(getStorageKey(ENTRIES_STORAGE_KEY));\n    if (savedEntries) {\n      const parsedEntries = JSON.parse(savedEntries, dateReviver);\n      setEntries(parsedEntries.map((entry: any) => ({\n        ...entry,\n        date: new Date(entry.date)\n      })));\n    }\n  }, [getStorageKey]);\n\n  // Save entries to localStorage\n  useEffect(() => {\n    if (entries.length > 0) {\n      localStorage.setItem(getStorageKey(ENTRIES_STORAGE_KEY), JSON.stringify(entries));\n    }\n  }, [entries, getStorageKey]);\n\n  // Load recurring payments from localStorage\n  useEffect(() => {\n    const savedRecurringPayments = localStorage.getItem(getStorageKey(RECURRING_PAYMENTS_STORAGE_KEY));\n    if (savedRecurringPayments) {\n      const parsedPayments = JSON.parse(savedRecurringPayments, dateReviver);\n      setRecurringPayments(parsedPayments.map((payment: any) => ({\n        ...payment,\n        startDate: new Date(payment.startDate),\n        endDate: payment.endDate ? new Date(payment.endDate) : undefined,\n        validFrom: new Date(payment.validFrom),\n        validUntil: payment.validUntil ? new Date(payment.validUntil) : undefined\n      })));\n    }\n  }, [getStorageKey]);\n\n  // Save recurring payments to localStorage\n  useEffect(() => {\n    if (recurringPayments.length > 0) {\n      localStorage.setItem(getStorageKey(RECURRING_PAYMENTS_STORAGE_KEY), JSON.stringify(recurringPayments));\n    }\n  }, [recurringPayments, getStorageKey]);\n\n  // Process recurring payments and generate entries for the entire month\n  useEffect(() => {\n    const processRecurringPayments = () => {\n      // Get current date without time\n      const today = new Date();\n      today.setHours(0, 0, 0, 0);\n      \n      // Process entries for the current viewed month\n      const monthStart = startOfMonth(currentDate);\n      const monthEnd = endOfMonth(currentDate);\n      \n      // Prepare new entries generated from recurring payments\n      const newEntries: FinancialEntry[] = [];\n\n      // Loop through all recurring payments\n      recurringPayments.forEach(payment => {\n        if (!payment.isActive) return;\n\n        // Check if the payment is currently valid\n        const isValid = isWithinDateRange(\n          today, \n          payment.validFrom, \n          payment.validUntil || new Date(9999, 11, 31) // If no end date, use far future\n        );\n\n        if (!isValid) return;\n\n        // Get dates to process based on schedule type\n        let datesToProcess: Date[] = [];\n        \n        // Define start date for processing (max of payment's start date or month start)\n        const processingStart = new Date(Math.max(payment.startDate.getTime(), monthStart.getTime()));\n        \n        // Define end date for processing (min of payment's end date, month end, or today)\n        const processingEnd = new Date(\n          Math.min(\n            payment.endDate ? payment.endDate.getTime() : 9999999999999,\n            monthEnd.getTime(),\n            today.getTime()\n          )\n        );\n\n        // Don't process if the processing period is invalid\n        if (isAfter(processingStart, processingEnd)) return;\n\n        // Get candidate dates based on schedule type\n        switch (payment.scheduleType) {\n          case 'specific-date':\n            // For monthly payments on a specific day of month\n            if (payment.frequency === 'monthly' && payment.dayOfMonth) {\n              // If today's day matches the payment day, and we haven't created this entry before\n              if (getDate(today) === payment.dayOfMonth) {\n                datesToProcess.push(new Date(today));\n              }\n            } \n            // For yearly payments on a specific day of a specific month\n            else if (payment.frequency === 'yearly' && payment.dayOfMonth) {\n              const paymentDate = new Date(\n                today.getFullYear(),\n                payment.startDate.getMonth(),\n                payment.dayOfMonth\n              );\n              \n              // If today's date matches the yearly payment date\n              if (isSameDay(today, paymentDate)) {\n                datesToProcess.push(new Date(today));\n              }\n            }\n            break;\n            \n          case 'weekdays-only':\n            // Get all weekdays within the processing window\n            datesToProcess = eachDayOfInterval({ start: processingStart, end: processingEnd })\n              .filter(date => !isWeekend(date));\n            break;\n            \n          case 'weekends-only':\n            // Get all weekend days within the processing window\n            datesToProcess = eachDayOfInterval({ start: processingStart, end: processingEnd })\n              .filter(date => isWeekend(date));\n            break;\n            \n          case 'custom-range':\n            // Get all dates within the custom range\n            datesToProcess = eachDayOfInterval({ start: processingStart, end: processingEnd });\n            \n            // Apply frequency filtering\n            switch (payment.frequency) {\n              case 'daily':\n                // All days are included, so no additional filtering\n                break;\n                \n              case 'weekly':\n                // Keep only days whose day of week matches the original start date\n                datesToProcess = datesToProcess.filter(date => \n                  date.getDay() === payment.startDate.getDay()\n                );\n                break;\n                \n              case 'monthly':\n                // Keep only days whose day of month matches the original start date\n                datesToProcess = datesToProcess.filter(date => \n                  getDate(date) === getDate(payment.startDate)\n                );\n                break;\n                \n              case 'yearly':\n                // Keep only days whose day and month match the original start date\n                datesToProcess = datesToProcess.filter(date => \n                  getDate(date) === getDate(payment.startDate) && \n                  date.getMonth() === payment.startDate.getMonth()\n                );\n                break;\n            }\n            break;\n        }\n\n        // Create entries for each date to process\n        datesToProcess.forEach(date => {\n          // Check if an entry for this recurring payment already exists on this date\n          const entryExists = entries.some(entry => \n            isSameDay(entry.date, date) && \n            entry.description === `[Recurring] ${payment.description}`\n          );\n\n          if (!entryExists) {\n            // Create a new entry for this recurring payment\n            newEntries.push({\n              id: uuidv4(),\n              date: new Date(date),\n              amount: payment.amount,\n              description: `[Recurring] ${payment.description}`,\n              type: payment.type\n            });\n          }\n        });\n      });\n\n      // Add new entries if any were generated\n      if (newEntries.length > 0) {\n        setEntries(prevEntries => [...prevEntries, ...newEntries]);\n      }\n    };\n\n    // Process recurring payments\n    if (recurringPayments.length > 0) {\n      processRecurringPayments();\n    }\n  }, [recurringPayments, entries, currentDate]);\n\n  // Helper function to check if a date is within a date range\n  const isWithinDateRange = (date: Date, start: Date, end: Date): boolean => {\n    return (\n      (isSameDay(date, start) || isAfter(date, start)) &&\n      (isSameDay(date, end) || isBefore(date, end))\n    );\n  };\n\n  // Calculate month data\n  const monthData = useMemo(() => {\n    const startDate = startOfMonth(currentDate);\n    const endDate = endOfMonth(currentDate);\n    const daysInMonth = eachDayOfInterval({ start: startDate, end: endDate });\n\n    const days = daysInMonth.reduce((acc, day) => {\n      const formattedDate = format(day, 'yyyy-MM-dd');\n      const dayEntries = entries.filter(entry => isSameDay(entry.date, day));\n      \n      const totalIncome = dayEntries\n        .filter(entry => entry.type === 'income')\n        .reduce((sum, entry) => sum + entry.amount, 0);\n      \n      const totalExpenses = dayEntries\n        .filter(entry => entry.type === 'expense')\n        .reduce((sum, entry) => sum + entry.amount, 0);\n\n      acc[formattedDate] = {\n        date: day,\n        entries: dayEntries,\n        totalIncome,\n        totalExpenses,\n        dailyBalance: totalIncome - totalExpenses,\n        runningBalance: 0, // Calculated after all days are processed\n      };\n\n      return acc;\n    }, {} as Record<string, any>);\n\n    // Calculate running balance\n    let runningBalance = 0;\n    for (const day of daysInMonth) {\n      const formattedDate = format(day, 'yyyy-MM-dd');\n      runningBalance += days[formattedDate].dailyBalance;\n      days[formattedDate].runningBalance = runningBalance;\n    }\n\n    // Calculate total income, expenses, and balance for the month\n    const totalIncome = Object.values(days).reduce(\n      (sum, day: any) => sum + day.totalIncome,\n      0\n    );\n    const totalExpenses = Object.values(days).reduce(\n      (sum, day: any) => sum + day.totalExpenses,\n      0\n    );\n\n    return {\n      days,\n      totalIncome,\n      totalExpenses,\n      monthlyBalance: totalIncome - totalExpenses,\n    };\n  }, [currentDate, entries]);\n\n  // Calculate year data\n  const yearData = useMemo(() => {\n    const year = currentDate.getFullYear();\n    const months = Array.from({ length: 12 }, (_, i) => i);\n\n    const monthSummaries = months.map(month => {\n      const monthEntries = entries.filter(entry => \n        entry.date.getFullYear() === year && \n        entry.date.getMonth() === month\n      );\n\n      const totalIncome = monthEntries\n        .filter(entry => entry.type === 'income')\n        .reduce((sum, entry) => sum + entry.amount, 0);\n      \n      const totalExpenses = monthEntries\n        .filter(entry => entry.type === 'expense')\n        .reduce((sum, entry) => sum + entry.amount, 0);\n\n      return {\n        month,\n        year,\n        totalIncome,\n        totalExpenses,\n        monthlyBalance: totalIncome - totalExpenses,\n      };\n    });\n\n    const totalIncome = monthSummaries.reduce(\n      (sum, month) => sum + month.totalIncome,\n      0\n    );\n    const totalExpenses = monthSummaries.reduce(\n      (sum, month) => sum + month.totalExpenses,\n      0\n    );\n\n    return {\n      year,\n      months: monthSummaries,\n      totalIncome,\n      totalExpenses,\n      yearlyBalance: totalIncome - totalExpenses,\n    };\n  }, [currentDate, entries]);\n\n  // Add a new financial entry\n  const addEntry = (entry: Omit<FinancialEntry, 'id'>) => {\n    const newEntry = {\n      ...entry,\n      id: uuidv4(),\n    };\n    setEntries(prevEntries => [...prevEntries, newEntry]);\n  };\n\n  // Update an existing financial entry\n  const updateEntry = (updatedEntry: FinancialEntry) => {\n    setEntries(prevEntries =>\n      prevEntries.map(entry => \n        entry.id === updatedEntry.id ? updatedEntry : entry\n      )\n    );\n  };\n\n  // Delete a financial entry\n  const deleteEntry = (id: string) => {\n    setEntries(prevEntries => prevEntries.filter(entry => entry.id !== id));\n  };\n\n  // Add a new recurring payment\n  const addRecurringPayment = (payment: Omit<RecurringPayment, 'id'>) => {\n    const newPayment = {\n      ...payment,\n      id: uuidv4(),\n    };\n    setRecurringPayments(prevPayments => [...prevPayments, newPayment]);\n  };\n\n  // Update an existing recurring payment\n  const updateRecurringPayment = (updatedPayment: RecurringPayment) => {\n    setRecurringPayments(prevPayments =>\n      prevPayments.map(payment =>\n        payment.id === updatedPayment.id ? updatedPayment : payment\n      )\n    );\n  };\n\n  // Delete a recurring payment\n  const deleteRecurringPayment = (id: string) => {\n    setRecurringPayments(prevPayments => \n      prevPayments.filter(payment => payment.id !== id)\n    );\n  };\n\n  return {\n    entries,\n    addEntry,\n    updateEntry,\n    deleteEntry,\n    recurringPayments,\n    addRecurringPayment,\n    updateRecurringPayment,\n    deleteRecurringPayment,\n    monthData,\n    yearData,\n  };\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}